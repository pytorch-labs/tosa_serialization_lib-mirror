// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TOSA_TOSA_H_
#define FLATBUFFERS_GENERATED_TOSA_TOSA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace tosa {

struct ARGMAX_Attribute;
struct ARGMAX_AttributeBuilder;

struct AVG_POOL2D_Attribute;
struct AVG_POOL2D_AttributeBuilder;

struct CONV2D_Attribute;
struct CONV2D_AttributeBuilder;

struct CONV3D_Attribute;
struct CONV3D_AttributeBuilder;

struct DEPTHWISE_CONV2D_Attribute;
struct DEPTHWISE_CONV2D_AttributeBuilder;

struct FFT2D_Attribute;
struct FFT2D_AttributeBuilder;

struct MATMUL_Attribute;
struct MATMUL_AttributeBuilder;

struct MAX_POOL2D_Attribute;
struct MAX_POOL2D_AttributeBuilder;

struct RFFT2D_Attribute;
struct RFFT2D_AttributeBuilder;

struct TRANSPOSE_CONV2D_Attribute;
struct TRANSPOSE_CONV2D_AttributeBuilder;

struct CLAMP_Attribute;
struct CLAMP_AttributeBuilder;

struct ERF_Attribute;
struct ERF_AttributeBuilder;

struct SIGMOID_Attribute;
struct SIGMOID_AttributeBuilder;

struct TANH_Attribute;
struct TANH_AttributeBuilder;

struct ADD_Attribute;
struct ADD_AttributeBuilder;

struct ARITHMETIC_RIGHT_SHIFT_Attribute;
struct ARITHMETIC_RIGHT_SHIFT_AttributeBuilder;

struct BITWISE_AND_Attribute;
struct BITWISE_AND_AttributeBuilder;

struct BITWISE_OR_Attribute;
struct BITWISE_OR_AttributeBuilder;

struct BITWISE_XOR_Attribute;
struct BITWISE_XOR_AttributeBuilder;

struct INTDIV_Attribute;
struct INTDIV_AttributeBuilder;

struct LOGICAL_AND_Attribute;
struct LOGICAL_AND_AttributeBuilder;

struct LOGICAL_LEFT_SHIFT_Attribute;
struct LOGICAL_LEFT_SHIFT_AttributeBuilder;

struct LOGICAL_RIGHT_SHIFT_Attribute;
struct LOGICAL_RIGHT_SHIFT_AttributeBuilder;

struct LOGICAL_OR_Attribute;
struct LOGICAL_OR_AttributeBuilder;

struct LOGICAL_XOR_Attribute;
struct LOGICAL_XOR_AttributeBuilder;

struct MAXIMUM_Attribute;
struct MAXIMUM_AttributeBuilder;

struct MINIMUM_Attribute;
struct MINIMUM_AttributeBuilder;

struct MUL_Attribute;
struct MUL_AttributeBuilder;

struct POW_Attribute;
struct POW_AttributeBuilder;

struct SUB_Attribute;
struct SUB_AttributeBuilder;

struct TABLE_Attribute;
struct TABLE_AttributeBuilder;

struct ABS_Attribute;
struct ABS_AttributeBuilder;

struct BITWISE_NOT_Attribute;
struct BITWISE_NOT_AttributeBuilder;

struct CEIL_Attribute;
struct CEIL_AttributeBuilder;

struct CLZ_Attribute;
struct CLZ_AttributeBuilder;

struct COS_Attribute;
struct COS_AttributeBuilder;

struct EXP_Attribute;
struct EXP_AttributeBuilder;

struct FLOOR_Attribute;
struct FLOOR_AttributeBuilder;

struct LOG_Attribute;
struct LOG_AttributeBuilder;

struct LOGICAL_NOT_Attribute;
struct LOGICAL_NOT_AttributeBuilder;

struct NEGATE_Attribute;
struct NEGATE_AttributeBuilder;

struct RECIPROCAL_Attribute;
struct RECIPROCAL_AttributeBuilder;

struct RSQRT_Attribute;
struct RSQRT_AttributeBuilder;

struct SIN_Attribute;
struct SIN_AttributeBuilder;

struct SELECT_Attribute;
struct SELECT_AttributeBuilder;

struct EQUAL_Attribute;
struct EQUAL_AttributeBuilder;

struct GREATER_Attribute;
struct GREATER_AttributeBuilder;

struct GREATER_EQUAL_Attribute;
struct GREATER_EQUAL_AttributeBuilder;

struct REDUCE_ALL_Attribute;
struct REDUCE_ALL_AttributeBuilder;

struct REDUCE_ANY_Attribute;
struct REDUCE_ANY_AttributeBuilder;

struct REDUCE_MAX_Attribute;
struct REDUCE_MAX_AttributeBuilder;

struct REDUCE_MIN_Attribute;
struct REDUCE_MIN_AttributeBuilder;

struct REDUCE_PRODUCT_Attribute;
struct REDUCE_PRODUCT_AttributeBuilder;

struct REDUCE_SUM_Attribute;
struct REDUCE_SUM_AttributeBuilder;

struct CONCAT_Attribute;
struct CONCAT_AttributeBuilder;

struct PAD_Attribute;
struct PAD_AttributeBuilder;

struct RESHAPE_Attribute;
struct RESHAPE_AttributeBuilder;

struct REVERSE_Attribute;
struct REVERSE_AttributeBuilder;

struct SLICE_Attribute;
struct SLICE_AttributeBuilder;

struct TILE_Attribute;
struct TILE_AttributeBuilder;

struct TRANSPOSE_Attribute;
struct TRANSPOSE_AttributeBuilder;

struct GATHER_Attribute;
struct GATHER_AttributeBuilder;

struct SCATTER_Attribute;
struct SCATTER_AttributeBuilder;

struct RESIZE_Attribute;
struct RESIZE_AttributeBuilder;

struct CAST_Attribute;
struct CAST_AttributeBuilder;

struct CAST_STOCHASTIC_Attribute;
struct CAST_STOCHASTIC_AttributeBuilder;

struct RESCALE_Attribute;
struct RESCALE_AttributeBuilder;

struct CONST_Attribute;
struct CONST_AttributeBuilder;

struct RAND_SEED_Attribute;
struct RAND_SEED_AttributeBuilder;

struct RAND_UNIFORM_Attribute;
struct RAND_UNIFORM_AttributeBuilder;

struct IDENTITY_Attribute;
struct IDENTITY_AttributeBuilder;

struct CUSTOM_Attribute;
struct CUSTOM_AttributeBuilder;

struct COND_IF_Attribute;
struct COND_IF_AttributeBuilder;

struct WHILE_LOOP_Attribute;
struct WHILE_LOOP_AttributeBuilder;

struct YIELD_Attribute;
struct YIELD_AttributeBuilder;

struct VARIABLE_Attribute;
struct VARIABLE_AttributeBuilder;

struct VARIABLE_WRITE_Attribute;
struct VARIABLE_WRITE_AttributeBuilder;

struct VARIABLE_READ_Attribute;
struct VARIABLE_READ_AttributeBuilder;

struct CONST_SHAPE_Attribute;
struct CONST_SHAPE_AttributeBuilder;

struct Version;
struct VersionBuilder;

struct TosaTensor;
struct TosaTensorBuilder;

struct TosaOperator;
struct TosaOperatorBuilder;

struct TosaBasicBlock;
struct TosaBasicBlockBuilder;

struct TosaRegion;
struct TosaRegionBuilder;

struct TosaGraph;
struct TosaGraphBuilder;

enum DType : uint32_t {
  DType_UNKNOWN = 0,
  DType_BOOL = 1,
  DType_UINT8 = 2,
  DType_INT4 = 3,
  DType_INT8 = 4,
  DType_INT16 = 5,
  DType_INT32 = 6,
  DType_INT48 = 7,
  DType_FP32 = 8,
  DType_UINT16 = 9,
  DType_FP16 = 10,
  DType_BF16 = 11,
  DType_SHAPE = 12,
  DType_FP8E4M3 = 13,
  DType_FP8E5M2 = 14,
  DType_MIN = DType_UNKNOWN,
  DType_MAX = DType_FP8E5M2
};

inline const DType (&EnumValuesDType())[15] {
  static const DType values[] = {
    DType_UNKNOWN,
    DType_BOOL,
    DType_UINT8,
    DType_INT4,
    DType_INT8,
    DType_INT16,
    DType_INT32,
    DType_INT48,
    DType_FP32,
    DType_UINT16,
    DType_FP16,
    DType_BF16,
    DType_SHAPE,
    DType_FP8E4M3,
    DType_FP8E5M2
  };
  return values;
}

inline const char * const *EnumNamesDType() {
  static const char * const names[16] = {
    "UNKNOWN",
    "BOOL",
    "UINT8",
    "INT4",
    "INT8",
    "INT16",
    "INT32",
    "INT48",
    "FP32",
    "UINT16",
    "FP16",
    "BF16",
    "SHAPE",
    "FP8E4M3",
    "FP8E5M2",
    nullptr
  };
  return names;
}

inline const char *EnumNameDType(DType e) {
  if (::flatbuffers::IsOutRange(e, DType_UNKNOWN, DType_FP8E5M2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDType()[index];
}

enum ResizeMode : uint32_t {
  ResizeMode_UNKNOWN = 0,
  ResizeMode_NEAREST = 1,
  ResizeMode_BILINEAR = 2,
  ResizeMode_MIN = ResizeMode_UNKNOWN,
  ResizeMode_MAX = ResizeMode_BILINEAR
};

inline const ResizeMode (&EnumValuesResizeMode())[3] {
  static const ResizeMode values[] = {
    ResizeMode_UNKNOWN,
    ResizeMode_NEAREST,
    ResizeMode_BILINEAR
  };
  return values;
}

inline const char * const *EnumNamesResizeMode() {
  static const char * const names[4] = {
    "UNKNOWN",
    "NEAREST",
    "BILINEAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMode(ResizeMode e) {
  if (::flatbuffers::IsOutRange(e, ResizeMode_UNKNOWN, ResizeMode_BILINEAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResizeMode()[index];
}

enum NanPropagationMode : uint32_t {
  NanPropagationMode_UNKNOWN = 0,
  NanPropagationMode_PROPAGATE = 1,
  NanPropagationMode_IGNORE = 2,
  NanPropagationMode_MIN = NanPropagationMode_UNKNOWN,
  NanPropagationMode_MAX = NanPropagationMode_IGNORE
};

inline const NanPropagationMode (&EnumValuesNanPropagationMode())[3] {
  static const NanPropagationMode values[] = {
    NanPropagationMode_UNKNOWN,
    NanPropagationMode_PROPAGATE,
    NanPropagationMode_IGNORE
  };
  return values;
}

inline const char * const *EnumNamesNanPropagationMode() {
  static const char * const names[4] = {
    "UNKNOWN",
    "PROPAGATE",
    "IGNORE",
    nullptr
  };
  return names;
}

inline const char *EnumNameNanPropagationMode(NanPropagationMode e) {
  if (::flatbuffers::IsOutRange(e, NanPropagationMode_UNKNOWN, NanPropagationMode_IGNORE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNanPropagationMode()[index];
}

enum Op : uint32_t {
  Op_UNKNOWN = 0,
  Op_ARGMAX = 1,
  Op_AVG_POOL2D = 2,
  Op_CONV2D = 3,
  Op_CONV3D = 4,
  Op_DEPTHWISE_CONV2D = 5,
  Op_FFT2D = 6,
  Op_MATMUL = 7,
  Op_MAX_POOL2D = 8,
  Op_RFFT2D = 9,
  Op_TRANSPOSE_CONV2D = 10,
  Op_CLAMP = 11,
  Op_ERF = 12,
  Op_SIGMOID = 13,
  Op_TANH = 14,
  Op_ADD = 15,
  Op_ARITHMETIC_RIGHT_SHIFT = 16,
  Op_BITWISE_AND = 17,
  Op_BITWISE_OR = 18,
  Op_BITWISE_XOR = 19,
  Op_INTDIV = 20,
  Op_LOGICAL_AND = 21,
  Op_LOGICAL_LEFT_SHIFT = 22,
  Op_LOGICAL_RIGHT_SHIFT = 23,
  Op_LOGICAL_OR = 24,
  Op_LOGICAL_XOR = 25,
  Op_MAXIMUM = 26,
  Op_MINIMUM = 27,
  Op_MUL = 28,
  Op_POW = 29,
  Op_SUB = 30,
  Op_TABLE = 31,
  Op_ABS = 32,
  Op_BITWISE_NOT = 33,
  Op_CEIL = 34,
  Op_CLZ = 35,
  Op_COS = 36,
  Op_EXP = 37,
  Op_FLOOR = 38,
  Op_LOG = 39,
  Op_LOGICAL_NOT = 40,
  Op_NEGATE = 41,
  Op_RECIPROCAL = 42,
  Op_RSQRT = 43,
  Op_SIN = 44,
  Op_SELECT = 45,
  Op_EQUAL = 46,
  Op_GREATER = 47,
  Op_GREATER_EQUAL = 48,
  Op_REDUCE_ALL = 49,
  Op_REDUCE_ANY = 50,
  Op_REDUCE_MAX = 51,
  Op_REDUCE_MIN = 52,
  Op_REDUCE_PRODUCT = 53,
  Op_REDUCE_SUM = 54,
  Op_CONCAT = 55,
  Op_PAD = 56,
  Op_RESHAPE = 57,
  Op_REVERSE = 58,
  Op_SLICE = 59,
  Op_TILE = 60,
  Op_TRANSPOSE = 61,
  Op_GATHER = 62,
  Op_SCATTER = 63,
  Op_RESIZE = 64,
  Op_CAST = 65,
  Op_CAST_STOCHASTIC = 66,
  Op_RESCALE = 67,
  Op_CONST = 68,
  Op_RAND_SEED = 69,
  Op_RAND_UNIFORM = 70,
  Op_IDENTITY = 71,
  Op_CUSTOM = 72,
  Op_COND_IF = 73,
  Op_WHILE_LOOP = 74,
  Op_YIELD = 75,
  Op_VARIABLE = 76,
  Op_VARIABLE_WRITE = 77,
  Op_VARIABLE_READ = 78,
  Op_CONST_SHAPE = 79,
  Op_MIN = Op_UNKNOWN,
  Op_MAX = Op_CONST_SHAPE
};

inline const Op (&EnumValuesOp())[80] {
  static const Op values[] = {
    Op_UNKNOWN,
    Op_ARGMAX,
    Op_AVG_POOL2D,
    Op_CONV2D,
    Op_CONV3D,
    Op_DEPTHWISE_CONV2D,
    Op_FFT2D,
    Op_MATMUL,
    Op_MAX_POOL2D,
    Op_RFFT2D,
    Op_TRANSPOSE_CONV2D,
    Op_CLAMP,
    Op_ERF,
    Op_SIGMOID,
    Op_TANH,
    Op_ADD,
    Op_ARITHMETIC_RIGHT_SHIFT,
    Op_BITWISE_AND,
    Op_BITWISE_OR,
    Op_BITWISE_XOR,
    Op_INTDIV,
    Op_LOGICAL_AND,
    Op_LOGICAL_LEFT_SHIFT,
    Op_LOGICAL_RIGHT_SHIFT,
    Op_LOGICAL_OR,
    Op_LOGICAL_XOR,
    Op_MAXIMUM,
    Op_MINIMUM,
    Op_MUL,
    Op_POW,
    Op_SUB,
    Op_TABLE,
    Op_ABS,
    Op_BITWISE_NOT,
    Op_CEIL,
    Op_CLZ,
    Op_COS,
    Op_EXP,
    Op_FLOOR,
    Op_LOG,
    Op_LOGICAL_NOT,
    Op_NEGATE,
    Op_RECIPROCAL,
    Op_RSQRT,
    Op_SIN,
    Op_SELECT,
    Op_EQUAL,
    Op_GREATER,
    Op_GREATER_EQUAL,
    Op_REDUCE_ALL,
    Op_REDUCE_ANY,
    Op_REDUCE_MAX,
    Op_REDUCE_MIN,
    Op_REDUCE_PRODUCT,
    Op_REDUCE_SUM,
    Op_CONCAT,
    Op_PAD,
    Op_RESHAPE,
    Op_REVERSE,
    Op_SLICE,
    Op_TILE,
    Op_TRANSPOSE,
    Op_GATHER,
    Op_SCATTER,
    Op_RESIZE,
    Op_CAST,
    Op_CAST_STOCHASTIC,
    Op_RESCALE,
    Op_CONST,
    Op_RAND_SEED,
    Op_RAND_UNIFORM,
    Op_IDENTITY,
    Op_CUSTOM,
    Op_COND_IF,
    Op_WHILE_LOOP,
    Op_YIELD,
    Op_VARIABLE,
    Op_VARIABLE_WRITE,
    Op_VARIABLE_READ,
    Op_CONST_SHAPE
  };
  return values;
}

inline const char * const *EnumNamesOp() {
  static const char * const names[81] = {
    "UNKNOWN",
    "ARGMAX",
    "AVG_POOL2D",
    "CONV2D",
    "CONV3D",
    "DEPTHWISE_CONV2D",
    "FFT2D",
    "MATMUL",
    "MAX_POOL2D",
    "RFFT2D",
    "TRANSPOSE_CONV2D",
    "CLAMP",
    "ERF",
    "SIGMOID",
    "TANH",
    "ADD",
    "ARITHMETIC_RIGHT_SHIFT",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "INTDIV",
    "LOGICAL_AND",
    "LOGICAL_LEFT_SHIFT",
    "LOGICAL_RIGHT_SHIFT",
    "LOGICAL_OR",
    "LOGICAL_XOR",
    "MAXIMUM",
    "MINIMUM",
    "MUL",
    "POW",
    "SUB",
    "TABLE",
    "ABS",
    "BITWISE_NOT",
    "CEIL",
    "CLZ",
    "COS",
    "EXP",
    "FLOOR",
    "LOG",
    "LOGICAL_NOT",
    "NEGATE",
    "RECIPROCAL",
    "RSQRT",
    "SIN",
    "SELECT",
    "EQUAL",
    "GREATER",
    "GREATER_EQUAL",
    "REDUCE_ALL",
    "REDUCE_ANY",
    "REDUCE_MAX",
    "REDUCE_MIN",
    "REDUCE_PRODUCT",
    "REDUCE_SUM",
    "CONCAT",
    "PAD",
    "RESHAPE",
    "REVERSE",
    "SLICE",
    "TILE",
    "TRANSPOSE",
    "GATHER",
    "SCATTER",
    "RESIZE",
    "CAST",
    "CAST_STOCHASTIC",
    "RESCALE",
    "CONST",
    "RAND_SEED",
    "RAND_UNIFORM",
    "IDENTITY",
    "CUSTOM",
    "COND_IF",
    "WHILE_LOOP",
    "YIELD",
    "VARIABLE",
    "VARIABLE_WRITE",
    "VARIABLE_READ",
    "CONST_SHAPE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOp(Op e) {
  if (::flatbuffers::IsOutRange(e, Op_UNKNOWN, Op_CONST_SHAPE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOp()[index];
}

enum Attribute : uint8_t {
  Attribute_NONE = 0,
  Attribute_ARGMAX_Attribute = 1,
  Attribute_AVG_POOL2D_Attribute = 2,
  Attribute_CONV2D_Attribute = 3,
  Attribute_CONV3D_Attribute = 4,
  Attribute_DEPTHWISE_CONV2D_Attribute = 5,
  Attribute_FFT2D_Attribute = 6,
  Attribute_MATMUL_Attribute = 7,
  Attribute_MAX_POOL2D_Attribute = 8,
  Attribute_RFFT2D_Attribute = 9,
  Attribute_TRANSPOSE_CONV2D_Attribute = 10,
  Attribute_CLAMP_Attribute = 11,
  Attribute_ERF_Attribute = 12,
  Attribute_SIGMOID_Attribute = 13,
  Attribute_TANH_Attribute = 14,
  Attribute_ADD_Attribute = 15,
  Attribute_ARITHMETIC_RIGHT_SHIFT_Attribute = 16,
  Attribute_BITWISE_AND_Attribute = 17,
  Attribute_BITWISE_OR_Attribute = 18,
  Attribute_BITWISE_XOR_Attribute = 19,
  Attribute_INTDIV_Attribute = 20,
  Attribute_LOGICAL_AND_Attribute = 21,
  Attribute_LOGICAL_LEFT_SHIFT_Attribute = 22,
  Attribute_LOGICAL_RIGHT_SHIFT_Attribute = 23,
  Attribute_LOGICAL_OR_Attribute = 24,
  Attribute_LOGICAL_XOR_Attribute = 25,
  Attribute_MAXIMUM_Attribute = 26,
  Attribute_MINIMUM_Attribute = 27,
  Attribute_MUL_Attribute = 28,
  Attribute_POW_Attribute = 29,
  Attribute_SUB_Attribute = 30,
  Attribute_TABLE_Attribute = 31,
  Attribute_ABS_Attribute = 32,
  Attribute_BITWISE_NOT_Attribute = 33,
  Attribute_CEIL_Attribute = 34,
  Attribute_CLZ_Attribute = 35,
  Attribute_COS_Attribute = 36,
  Attribute_EXP_Attribute = 37,
  Attribute_FLOOR_Attribute = 38,
  Attribute_LOG_Attribute = 39,
  Attribute_LOGICAL_NOT_Attribute = 40,
  Attribute_NEGATE_Attribute = 41,
  Attribute_RECIPROCAL_Attribute = 42,
  Attribute_RSQRT_Attribute = 43,
  Attribute_SIN_Attribute = 44,
  Attribute_SELECT_Attribute = 45,
  Attribute_EQUAL_Attribute = 46,
  Attribute_GREATER_Attribute = 47,
  Attribute_GREATER_EQUAL_Attribute = 48,
  Attribute_REDUCE_ALL_Attribute = 49,
  Attribute_REDUCE_ANY_Attribute = 50,
  Attribute_REDUCE_MAX_Attribute = 51,
  Attribute_REDUCE_MIN_Attribute = 52,
  Attribute_REDUCE_PRODUCT_Attribute = 53,
  Attribute_REDUCE_SUM_Attribute = 54,
  Attribute_CONCAT_Attribute = 55,
  Attribute_PAD_Attribute = 56,
  Attribute_RESHAPE_Attribute = 57,
  Attribute_REVERSE_Attribute = 58,
  Attribute_SLICE_Attribute = 59,
  Attribute_TILE_Attribute = 60,
  Attribute_TRANSPOSE_Attribute = 61,
  Attribute_GATHER_Attribute = 62,
  Attribute_SCATTER_Attribute = 63,
  Attribute_RESIZE_Attribute = 64,
  Attribute_CAST_Attribute = 65,
  Attribute_CAST_STOCHASTIC_Attribute = 66,
  Attribute_RESCALE_Attribute = 67,
  Attribute_CONST_Attribute = 68,
  Attribute_RAND_SEED_Attribute = 69,
  Attribute_RAND_UNIFORM_Attribute = 70,
  Attribute_IDENTITY_Attribute = 71,
  Attribute_CUSTOM_Attribute = 72,
  Attribute_COND_IF_Attribute = 73,
  Attribute_WHILE_LOOP_Attribute = 74,
  Attribute_YIELD_Attribute = 75,
  Attribute_VARIABLE_Attribute = 76,
  Attribute_VARIABLE_WRITE_Attribute = 77,
  Attribute_VARIABLE_READ_Attribute = 78,
  Attribute_CONST_SHAPE_Attribute = 79,
  Attribute_MIN = Attribute_NONE,
  Attribute_MAX = Attribute_CONST_SHAPE_Attribute
};

inline const Attribute (&EnumValuesAttribute())[80] {
  static const Attribute values[] = {
    Attribute_NONE,
    Attribute_ARGMAX_Attribute,
    Attribute_AVG_POOL2D_Attribute,
    Attribute_CONV2D_Attribute,
    Attribute_CONV3D_Attribute,
    Attribute_DEPTHWISE_CONV2D_Attribute,
    Attribute_FFT2D_Attribute,
    Attribute_MATMUL_Attribute,
    Attribute_MAX_POOL2D_Attribute,
    Attribute_RFFT2D_Attribute,
    Attribute_TRANSPOSE_CONV2D_Attribute,
    Attribute_CLAMP_Attribute,
    Attribute_ERF_Attribute,
    Attribute_SIGMOID_Attribute,
    Attribute_TANH_Attribute,
    Attribute_ADD_Attribute,
    Attribute_ARITHMETIC_RIGHT_SHIFT_Attribute,
    Attribute_BITWISE_AND_Attribute,
    Attribute_BITWISE_OR_Attribute,
    Attribute_BITWISE_XOR_Attribute,
    Attribute_INTDIV_Attribute,
    Attribute_LOGICAL_AND_Attribute,
    Attribute_LOGICAL_LEFT_SHIFT_Attribute,
    Attribute_LOGICAL_RIGHT_SHIFT_Attribute,
    Attribute_LOGICAL_OR_Attribute,
    Attribute_LOGICAL_XOR_Attribute,
    Attribute_MAXIMUM_Attribute,
    Attribute_MINIMUM_Attribute,
    Attribute_MUL_Attribute,
    Attribute_POW_Attribute,
    Attribute_SUB_Attribute,
    Attribute_TABLE_Attribute,
    Attribute_ABS_Attribute,
    Attribute_BITWISE_NOT_Attribute,
    Attribute_CEIL_Attribute,
    Attribute_CLZ_Attribute,
    Attribute_COS_Attribute,
    Attribute_EXP_Attribute,
    Attribute_FLOOR_Attribute,
    Attribute_LOG_Attribute,
    Attribute_LOGICAL_NOT_Attribute,
    Attribute_NEGATE_Attribute,
    Attribute_RECIPROCAL_Attribute,
    Attribute_RSQRT_Attribute,
    Attribute_SIN_Attribute,
    Attribute_SELECT_Attribute,
    Attribute_EQUAL_Attribute,
    Attribute_GREATER_Attribute,
    Attribute_GREATER_EQUAL_Attribute,
    Attribute_REDUCE_ALL_Attribute,
    Attribute_REDUCE_ANY_Attribute,
    Attribute_REDUCE_MAX_Attribute,
    Attribute_REDUCE_MIN_Attribute,
    Attribute_REDUCE_PRODUCT_Attribute,
    Attribute_REDUCE_SUM_Attribute,
    Attribute_CONCAT_Attribute,
    Attribute_PAD_Attribute,
    Attribute_RESHAPE_Attribute,
    Attribute_REVERSE_Attribute,
    Attribute_SLICE_Attribute,
    Attribute_TILE_Attribute,
    Attribute_TRANSPOSE_Attribute,
    Attribute_GATHER_Attribute,
    Attribute_SCATTER_Attribute,
    Attribute_RESIZE_Attribute,
    Attribute_CAST_Attribute,
    Attribute_CAST_STOCHASTIC_Attribute,
    Attribute_RESCALE_Attribute,
    Attribute_CONST_Attribute,
    Attribute_RAND_SEED_Attribute,
    Attribute_RAND_UNIFORM_Attribute,
    Attribute_IDENTITY_Attribute,
    Attribute_CUSTOM_Attribute,
    Attribute_COND_IF_Attribute,
    Attribute_WHILE_LOOP_Attribute,
    Attribute_YIELD_Attribute,
    Attribute_VARIABLE_Attribute,
    Attribute_VARIABLE_WRITE_Attribute,
    Attribute_VARIABLE_READ_Attribute,
    Attribute_CONST_SHAPE_Attribute
  };
  return values;
}

inline const char * const *EnumNamesAttribute() {
  static const char * const names[81] = {
    "NONE",
    "ARGMAX_Attribute",
    "AVG_POOL2D_Attribute",
    "CONV2D_Attribute",
    "CONV3D_Attribute",
    "DEPTHWISE_CONV2D_Attribute",
    "FFT2D_Attribute",
    "MATMUL_Attribute",
    "MAX_POOL2D_Attribute",
    "RFFT2D_Attribute",
    "TRANSPOSE_CONV2D_Attribute",
    "CLAMP_Attribute",
    "ERF_Attribute",
    "SIGMOID_Attribute",
    "TANH_Attribute",
    "ADD_Attribute",
    "ARITHMETIC_RIGHT_SHIFT_Attribute",
    "BITWISE_AND_Attribute",
    "BITWISE_OR_Attribute",
    "BITWISE_XOR_Attribute",
    "INTDIV_Attribute",
    "LOGICAL_AND_Attribute",
    "LOGICAL_LEFT_SHIFT_Attribute",
    "LOGICAL_RIGHT_SHIFT_Attribute",
    "LOGICAL_OR_Attribute",
    "LOGICAL_XOR_Attribute",
    "MAXIMUM_Attribute",
    "MINIMUM_Attribute",
    "MUL_Attribute",
    "POW_Attribute",
    "SUB_Attribute",
    "TABLE_Attribute",
    "ABS_Attribute",
    "BITWISE_NOT_Attribute",
    "CEIL_Attribute",
    "CLZ_Attribute",
    "COS_Attribute",
    "EXP_Attribute",
    "FLOOR_Attribute",
    "LOG_Attribute",
    "LOGICAL_NOT_Attribute",
    "NEGATE_Attribute",
    "RECIPROCAL_Attribute",
    "RSQRT_Attribute",
    "SIN_Attribute",
    "SELECT_Attribute",
    "EQUAL_Attribute",
    "GREATER_Attribute",
    "GREATER_EQUAL_Attribute",
    "REDUCE_ALL_Attribute",
    "REDUCE_ANY_Attribute",
    "REDUCE_MAX_Attribute",
    "REDUCE_MIN_Attribute",
    "REDUCE_PRODUCT_Attribute",
    "REDUCE_SUM_Attribute",
    "CONCAT_Attribute",
    "PAD_Attribute",
    "RESHAPE_Attribute",
    "REVERSE_Attribute",
    "SLICE_Attribute",
    "TILE_Attribute",
    "TRANSPOSE_Attribute",
    "GATHER_Attribute",
    "SCATTER_Attribute",
    "RESIZE_Attribute",
    "CAST_Attribute",
    "CAST_STOCHASTIC_Attribute",
    "RESCALE_Attribute",
    "CONST_Attribute",
    "RAND_SEED_Attribute",
    "RAND_UNIFORM_Attribute",
    "IDENTITY_Attribute",
    "CUSTOM_Attribute",
    "COND_IF_Attribute",
    "WHILE_LOOP_Attribute",
    "YIELD_Attribute",
    "VARIABLE_Attribute",
    "VARIABLE_WRITE_Attribute",
    "VARIABLE_READ_Attribute",
    "CONST_SHAPE_Attribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttribute(Attribute e) {
  if (::flatbuffers::IsOutRange(e, Attribute_NONE, Attribute_CONST_SHAPE_Attribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttribute()[index];
}

template<typename T> struct AttributeTraits {
  static const Attribute enum_value = Attribute_NONE;
};

template<> struct AttributeTraits<tosa::ARGMAX_Attribute> {
  static const Attribute enum_value = Attribute_ARGMAX_Attribute;
};

template<> struct AttributeTraits<tosa::AVG_POOL2D_Attribute> {
  static const Attribute enum_value = Attribute_AVG_POOL2D_Attribute;
};

template<> struct AttributeTraits<tosa::CONV2D_Attribute> {
  static const Attribute enum_value = Attribute_CONV2D_Attribute;
};

template<> struct AttributeTraits<tosa::CONV3D_Attribute> {
  static const Attribute enum_value = Attribute_CONV3D_Attribute;
};

template<> struct AttributeTraits<tosa::DEPTHWISE_CONV2D_Attribute> {
  static const Attribute enum_value = Attribute_DEPTHWISE_CONV2D_Attribute;
};

template<> struct AttributeTraits<tosa::FFT2D_Attribute> {
  static const Attribute enum_value = Attribute_FFT2D_Attribute;
};

template<> struct AttributeTraits<tosa::MATMUL_Attribute> {
  static const Attribute enum_value = Attribute_MATMUL_Attribute;
};

template<> struct AttributeTraits<tosa::MAX_POOL2D_Attribute> {
  static const Attribute enum_value = Attribute_MAX_POOL2D_Attribute;
};

template<> struct AttributeTraits<tosa::RFFT2D_Attribute> {
  static const Attribute enum_value = Attribute_RFFT2D_Attribute;
};

template<> struct AttributeTraits<tosa::TRANSPOSE_CONV2D_Attribute> {
  static const Attribute enum_value = Attribute_TRANSPOSE_CONV2D_Attribute;
};

template<> struct AttributeTraits<tosa::CLAMP_Attribute> {
  static const Attribute enum_value = Attribute_CLAMP_Attribute;
};

template<> struct AttributeTraits<tosa::ERF_Attribute> {
  static const Attribute enum_value = Attribute_ERF_Attribute;
};

template<> struct AttributeTraits<tosa::SIGMOID_Attribute> {
  static const Attribute enum_value = Attribute_SIGMOID_Attribute;
};

template<> struct AttributeTraits<tosa::TANH_Attribute> {
  static const Attribute enum_value = Attribute_TANH_Attribute;
};

template<> struct AttributeTraits<tosa::ADD_Attribute> {
  static const Attribute enum_value = Attribute_ADD_Attribute;
};

template<> struct AttributeTraits<tosa::ARITHMETIC_RIGHT_SHIFT_Attribute> {
  static const Attribute enum_value = Attribute_ARITHMETIC_RIGHT_SHIFT_Attribute;
};

template<> struct AttributeTraits<tosa::BITWISE_AND_Attribute> {
  static const Attribute enum_value = Attribute_BITWISE_AND_Attribute;
};

template<> struct AttributeTraits<tosa::BITWISE_OR_Attribute> {
  static const Attribute enum_value = Attribute_BITWISE_OR_Attribute;
};

template<> struct AttributeTraits<tosa::BITWISE_XOR_Attribute> {
  static const Attribute enum_value = Attribute_BITWISE_XOR_Attribute;
};

template<> struct AttributeTraits<tosa::INTDIV_Attribute> {
  static const Attribute enum_value = Attribute_INTDIV_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_AND_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_AND_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_LEFT_SHIFT_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_LEFT_SHIFT_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_RIGHT_SHIFT_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_RIGHT_SHIFT_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_OR_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_OR_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_XOR_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_XOR_Attribute;
};

template<> struct AttributeTraits<tosa::MAXIMUM_Attribute> {
  static const Attribute enum_value = Attribute_MAXIMUM_Attribute;
};

template<> struct AttributeTraits<tosa::MINIMUM_Attribute> {
  static const Attribute enum_value = Attribute_MINIMUM_Attribute;
};

template<> struct AttributeTraits<tosa::MUL_Attribute> {
  static const Attribute enum_value = Attribute_MUL_Attribute;
};

template<> struct AttributeTraits<tosa::POW_Attribute> {
  static const Attribute enum_value = Attribute_POW_Attribute;
};

template<> struct AttributeTraits<tosa::SUB_Attribute> {
  static const Attribute enum_value = Attribute_SUB_Attribute;
};

template<> struct AttributeTraits<tosa::TABLE_Attribute> {
  static const Attribute enum_value = Attribute_TABLE_Attribute;
};

template<> struct AttributeTraits<tosa::ABS_Attribute> {
  static const Attribute enum_value = Attribute_ABS_Attribute;
};

template<> struct AttributeTraits<tosa::BITWISE_NOT_Attribute> {
  static const Attribute enum_value = Attribute_BITWISE_NOT_Attribute;
};

template<> struct AttributeTraits<tosa::CEIL_Attribute> {
  static const Attribute enum_value = Attribute_CEIL_Attribute;
};

template<> struct AttributeTraits<tosa::CLZ_Attribute> {
  static const Attribute enum_value = Attribute_CLZ_Attribute;
};

template<> struct AttributeTraits<tosa::COS_Attribute> {
  static const Attribute enum_value = Attribute_COS_Attribute;
};

template<> struct AttributeTraits<tosa::EXP_Attribute> {
  static const Attribute enum_value = Attribute_EXP_Attribute;
};

template<> struct AttributeTraits<tosa::FLOOR_Attribute> {
  static const Attribute enum_value = Attribute_FLOOR_Attribute;
};

template<> struct AttributeTraits<tosa::LOG_Attribute> {
  static const Attribute enum_value = Attribute_LOG_Attribute;
};

template<> struct AttributeTraits<tosa::LOGICAL_NOT_Attribute> {
  static const Attribute enum_value = Attribute_LOGICAL_NOT_Attribute;
};

template<> struct AttributeTraits<tosa::NEGATE_Attribute> {
  static const Attribute enum_value = Attribute_NEGATE_Attribute;
};

template<> struct AttributeTraits<tosa::RECIPROCAL_Attribute> {
  static const Attribute enum_value = Attribute_RECIPROCAL_Attribute;
};

template<> struct AttributeTraits<tosa::RSQRT_Attribute> {
  static const Attribute enum_value = Attribute_RSQRT_Attribute;
};

template<> struct AttributeTraits<tosa::SIN_Attribute> {
  static const Attribute enum_value = Attribute_SIN_Attribute;
};

template<> struct AttributeTraits<tosa::SELECT_Attribute> {
  static const Attribute enum_value = Attribute_SELECT_Attribute;
};

template<> struct AttributeTraits<tosa::EQUAL_Attribute> {
  static const Attribute enum_value = Attribute_EQUAL_Attribute;
};

template<> struct AttributeTraits<tosa::GREATER_Attribute> {
  static const Attribute enum_value = Attribute_GREATER_Attribute;
};

template<> struct AttributeTraits<tosa::GREATER_EQUAL_Attribute> {
  static const Attribute enum_value = Attribute_GREATER_EQUAL_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_ALL_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_ALL_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_ANY_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_ANY_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_MAX_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_MAX_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_MIN_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_MIN_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_PRODUCT_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_PRODUCT_Attribute;
};

template<> struct AttributeTraits<tosa::REDUCE_SUM_Attribute> {
  static const Attribute enum_value = Attribute_REDUCE_SUM_Attribute;
};

template<> struct AttributeTraits<tosa::CONCAT_Attribute> {
  static const Attribute enum_value = Attribute_CONCAT_Attribute;
};

template<> struct AttributeTraits<tosa::PAD_Attribute> {
  static const Attribute enum_value = Attribute_PAD_Attribute;
};

template<> struct AttributeTraits<tosa::RESHAPE_Attribute> {
  static const Attribute enum_value = Attribute_RESHAPE_Attribute;
};

template<> struct AttributeTraits<tosa::REVERSE_Attribute> {
  static const Attribute enum_value = Attribute_REVERSE_Attribute;
};

template<> struct AttributeTraits<tosa::SLICE_Attribute> {
  static const Attribute enum_value = Attribute_SLICE_Attribute;
};

template<> struct AttributeTraits<tosa::TILE_Attribute> {
  static const Attribute enum_value = Attribute_TILE_Attribute;
};

template<> struct AttributeTraits<tosa::TRANSPOSE_Attribute> {
  static const Attribute enum_value = Attribute_TRANSPOSE_Attribute;
};

template<> struct AttributeTraits<tosa::GATHER_Attribute> {
  static const Attribute enum_value = Attribute_GATHER_Attribute;
};

template<> struct AttributeTraits<tosa::SCATTER_Attribute> {
  static const Attribute enum_value = Attribute_SCATTER_Attribute;
};

template<> struct AttributeTraits<tosa::RESIZE_Attribute> {
  static const Attribute enum_value = Attribute_RESIZE_Attribute;
};

template<> struct AttributeTraits<tosa::CAST_Attribute> {
  static const Attribute enum_value = Attribute_CAST_Attribute;
};

template<> struct AttributeTraits<tosa::CAST_STOCHASTIC_Attribute> {
  static const Attribute enum_value = Attribute_CAST_STOCHASTIC_Attribute;
};

template<> struct AttributeTraits<tosa::RESCALE_Attribute> {
  static const Attribute enum_value = Attribute_RESCALE_Attribute;
};

template<> struct AttributeTraits<tosa::CONST_Attribute> {
  static const Attribute enum_value = Attribute_CONST_Attribute;
};

template<> struct AttributeTraits<tosa::RAND_SEED_Attribute> {
  static const Attribute enum_value = Attribute_RAND_SEED_Attribute;
};

template<> struct AttributeTraits<tosa::RAND_UNIFORM_Attribute> {
  static const Attribute enum_value = Attribute_RAND_UNIFORM_Attribute;
};

template<> struct AttributeTraits<tosa::IDENTITY_Attribute> {
  static const Attribute enum_value = Attribute_IDENTITY_Attribute;
};

template<> struct AttributeTraits<tosa::CUSTOM_Attribute> {
  static const Attribute enum_value = Attribute_CUSTOM_Attribute;
};

template<> struct AttributeTraits<tosa::COND_IF_Attribute> {
  static const Attribute enum_value = Attribute_COND_IF_Attribute;
};

template<> struct AttributeTraits<tosa::WHILE_LOOP_Attribute> {
  static const Attribute enum_value = Attribute_WHILE_LOOP_Attribute;
};

template<> struct AttributeTraits<tosa::YIELD_Attribute> {
  static const Attribute enum_value = Attribute_YIELD_Attribute;
};

template<> struct AttributeTraits<tosa::VARIABLE_Attribute> {
  static const Attribute enum_value = Attribute_VARIABLE_Attribute;
};

template<> struct AttributeTraits<tosa::VARIABLE_WRITE_Attribute> {
  static const Attribute enum_value = Attribute_VARIABLE_WRITE_Attribute;
};

template<> struct AttributeTraits<tosa::VARIABLE_READ_Attribute> {
  static const Attribute enum_value = Attribute_VARIABLE_READ_Attribute;
};

template<> struct AttributeTraits<tosa::CONST_SHAPE_Attribute> {
  static const Attribute enum_value = Attribute_CONST_SHAPE_Attribute;
};

bool VerifyAttribute(::flatbuffers::Verifier &verifier, const void *obj, Attribute type);
bool VerifyAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct ARGMAX_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ARGMAX_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_NAN_MODE = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct ARGMAX_AttributeBuilder {
  typedef ARGMAX_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ARGMAX_Attribute::VT_AXIS, axis, 0);
  }
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(ARGMAX_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit ARGMAX_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ARGMAX_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ARGMAX_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ARGMAX_Attribute> CreateARGMAX_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  ARGMAX_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct AVG_POOL2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AVG_POOL2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD = 4,
    VT_KERNEL = 6,
    VT_STRIDE = 8,
    VT_INPUT_ZP = 10,
    VT_OUTPUT_ZP = 12,
    VT_ACC_TYPE = 14
  };
  const ::flatbuffers::Vector<int32_t> *pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
  }
  const ::flatbuffers::Vector<int32_t> *kernel() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KERNEL);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t output_zp() const {
    return GetField<int32_t>(VT_OUTPUT_ZP, 0);
  }
  tosa::DType acc_type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_ACC_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_KERNEL) &&
           verifier.VerifyVector(kernel()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACC_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct AVG_POOL2D_AttributeBuilder {
  typedef AVG_POOL2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad) {
    fbb_.AddOffset(AVG_POOL2D_Attribute::VT_PAD, pad);
  }
  void add_kernel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel) {
    fbb_.AddOffset(AVG_POOL2D_Attribute::VT_KERNEL, kernel);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(AVG_POOL2D_Attribute::VT_STRIDE, stride);
  }
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(AVG_POOL2D_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_output_zp(int32_t output_zp) {
    fbb_.AddElement<int32_t>(AVG_POOL2D_Attribute::VT_OUTPUT_ZP, output_zp, 0);
  }
  void add_acc_type(tosa::DType acc_type) {
    fbb_.AddElement<uint32_t>(AVG_POOL2D_Attribute::VT_ACC_TYPE, static_cast<uint32_t>(acc_type), 0);
  }
  explicit AVG_POOL2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AVG_POOL2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AVG_POOL2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AVG_POOL2D_Attribute> CreateAVG_POOL2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    int32_t input_zp = 0,
    int32_t output_zp = 0,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  AVG_POOL2D_AttributeBuilder builder_(_fbb);
  builder_.add_acc_type(acc_type);
  builder_.add_output_zp(output_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_stride(stride);
  builder_.add_kernel(kernel);
  builder_.add_pad(pad);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AVG_POOL2D_Attribute> CreateAVG_POOL2D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr,
    const std::vector<int32_t> *kernel = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    int32_t input_zp = 0,
    int32_t output_zp = 0,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
  auto kernel__ = kernel ? _fbb.CreateVector<int32_t>(*kernel) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return tosa::CreateAVG_POOL2D_Attribute(
      _fbb,
      pad__,
      kernel__,
      stride__,
      input_zp,
      output_zp,
      acc_type);
}

struct CONV2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONV2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD = 4,
    VT_STRIDE = 6,
    VT_DILATION = 8,
    VT_INPUT_ZP = 10,
    VT_WEIGHT_ZP = 12,
    VT_LOCAL_BOUND = 14,
    VT_ACC_TYPE = 16
  };
  const ::flatbuffers::Vector<int32_t> *pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const ::flatbuffers::Vector<int32_t> *dilation() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DILATION);
  }
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t weight_zp() const {
    return GetField<int32_t>(VT_WEIGHT_ZP, 0);
  }
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  tosa::DType acc_type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_ACC_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           VerifyField<uint32_t>(verifier, VT_ACC_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct CONV2D_AttributeBuilder {
  typedef CONV2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad) {
    fbb_.AddOffset(CONV2D_Attribute::VT_PAD, pad);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(CONV2D_Attribute::VT_STRIDE, stride);
  }
  void add_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation) {
    fbb_.AddOffset(CONV2D_Attribute::VT_DILATION, dilation);
  }
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(CONV2D_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_weight_zp(int32_t weight_zp) {
    fbb_.AddElement<int32_t>(CONV2D_Attribute::VT_WEIGHT_ZP, weight_zp, 0);
  }
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(CONV2D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  void add_acc_type(tosa::DType acc_type) {
    fbb_.AddElement<uint32_t>(CONV2D_Attribute::VT_ACC_TYPE, static_cast<uint32_t>(acc_type), 0);
  }
  explicit CONV2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONV2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONV2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONV2D_Attribute> CreateCONV2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation = 0,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  CONV2D_AttributeBuilder builder_(_fbb);
  builder_.add_acc_type(acc_type);
  builder_.add_weight_zp(weight_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_pad(pad);
  builder_.add_local_bound(local_bound);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CONV2D_Attribute> CreateCONV2D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *dilation = nullptr,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int32_t>(*dilation) : 0;
  return tosa::CreateCONV2D_Attribute(
      _fbb,
      pad__,
      stride__,
      dilation__,
      input_zp,
      weight_zp,
      local_bound,
      acc_type);
}

struct CONV3D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONV3D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD = 4,
    VT_STRIDE = 6,
    VT_DILATION = 8,
    VT_INPUT_ZP = 10,
    VT_WEIGHT_ZP = 12,
    VT_LOCAL_BOUND = 14,
    VT_ACC_TYPE = 16
  };
  const ::flatbuffers::Vector<int32_t> *pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const ::flatbuffers::Vector<int32_t> *dilation() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DILATION);
  }
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t weight_zp() const {
    return GetField<int32_t>(VT_WEIGHT_ZP, 0);
  }
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  tosa::DType acc_type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_ACC_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           VerifyField<uint32_t>(verifier, VT_ACC_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct CONV3D_AttributeBuilder {
  typedef CONV3D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad) {
    fbb_.AddOffset(CONV3D_Attribute::VT_PAD, pad);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(CONV3D_Attribute::VT_STRIDE, stride);
  }
  void add_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation) {
    fbb_.AddOffset(CONV3D_Attribute::VT_DILATION, dilation);
  }
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(CONV3D_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_weight_zp(int32_t weight_zp) {
    fbb_.AddElement<int32_t>(CONV3D_Attribute::VT_WEIGHT_ZP, weight_zp, 0);
  }
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(CONV3D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  void add_acc_type(tosa::DType acc_type) {
    fbb_.AddElement<uint32_t>(CONV3D_Attribute::VT_ACC_TYPE, static_cast<uint32_t>(acc_type), 0);
  }
  explicit CONV3D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONV3D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONV3D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONV3D_Attribute> CreateCONV3D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation = 0,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  CONV3D_AttributeBuilder builder_(_fbb);
  builder_.add_acc_type(acc_type);
  builder_.add_weight_zp(weight_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_pad(pad);
  builder_.add_local_bound(local_bound);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CONV3D_Attribute> CreateCONV3D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *dilation = nullptr,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int32_t>(*dilation) : 0;
  return tosa::CreateCONV3D_Attribute(
      _fbb,
      pad__,
      stride__,
      dilation__,
      input_zp,
      weight_zp,
      local_bound,
      acc_type);
}

struct DEPTHWISE_CONV2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DEPTHWISE_CONV2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD = 4,
    VT_STRIDE = 6,
    VT_DILATION = 8,
    VT_INPUT_ZP = 10,
    VT_WEIGHT_ZP = 12,
    VT_LOCAL_BOUND = 14,
    VT_ACC_TYPE = 16
  };
  const ::flatbuffers::Vector<int32_t> *pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const ::flatbuffers::Vector<int32_t> *dilation() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DILATION);
  }
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t weight_zp() const {
    return GetField<int32_t>(VT_WEIGHT_ZP, 0);
  }
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  tosa::DType acc_type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_ACC_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           VerifyField<uint32_t>(verifier, VT_ACC_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct DEPTHWISE_CONV2D_AttributeBuilder {
  typedef DEPTHWISE_CONV2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad) {
    fbb_.AddOffset(DEPTHWISE_CONV2D_Attribute::VT_PAD, pad);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(DEPTHWISE_CONV2D_Attribute::VT_STRIDE, stride);
  }
  void add_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation) {
    fbb_.AddOffset(DEPTHWISE_CONV2D_Attribute::VT_DILATION, dilation);
  }
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV2D_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_weight_zp(int32_t weight_zp) {
    fbb_.AddElement<int32_t>(DEPTHWISE_CONV2D_Attribute::VT_WEIGHT_ZP, weight_zp, 0);
  }
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(DEPTHWISE_CONV2D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  void add_acc_type(tosa::DType acc_type) {
    fbb_.AddElement<uint32_t>(DEPTHWISE_CONV2D_Attribute::VT_ACC_TYPE, static_cast<uint32_t>(acc_type), 0);
  }
  explicit DEPTHWISE_CONV2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DEPTHWISE_CONV2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DEPTHWISE_CONV2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DEPTHWISE_CONV2D_Attribute> CreateDEPTHWISE_CONV2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation = 0,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  DEPTHWISE_CONV2D_AttributeBuilder builder_(_fbb);
  builder_.add_acc_type(acc_type);
  builder_.add_weight_zp(weight_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_pad(pad);
  builder_.add_local_bound(local_bound);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DEPTHWISE_CONV2D_Attribute> CreateDEPTHWISE_CONV2D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *dilation = nullptr,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int32_t>(*dilation) : 0;
  return tosa::CreateDEPTHWISE_CONV2D_Attribute(
      _fbb,
      pad__,
      stride__,
      dilation__,
      input_zp,
      weight_zp,
      local_bound,
      acc_type);
}

struct FFT2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FFT2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INVERSE = 4,
    VT_LOCAL_BOUND = 6
  };
  bool inverse() const {
    return GetField<uint8_t>(VT_INVERSE, 0) != 0;
  }
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INVERSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           verifier.EndTable();
  }
};

struct FFT2D_AttributeBuilder {
  typedef FFT2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inverse(bool inverse) {
    fbb_.AddElement<uint8_t>(FFT2D_Attribute::VT_INVERSE, static_cast<uint8_t>(inverse), 0);
  }
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(FFT2D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  explicit FFT2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FFT2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FFT2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FFT2D_Attribute> CreateFFT2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool inverse = false,
    bool local_bound = false) {
  FFT2D_AttributeBuilder builder_(_fbb);
  builder_.add_local_bound(local_bound);
  builder_.add_inverse(inverse);
  return builder_.Finish();
}

struct MATMUL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MATMUL_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A_ZP = 4,
    VT_B_ZP = 6
  };
  int32_t a_zp() const {
    return GetField<int32_t>(VT_A_ZP, 0);
  }
  int32_t b_zp() const {
    return GetField<int32_t>(VT_B_ZP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_B_ZP, 4) &&
           verifier.EndTable();
  }
};

struct MATMUL_AttributeBuilder {
  typedef MATMUL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a_zp(int32_t a_zp) {
    fbb_.AddElement<int32_t>(MATMUL_Attribute::VT_A_ZP, a_zp, 0);
  }
  void add_b_zp(int32_t b_zp) {
    fbb_.AddElement<int32_t>(MATMUL_Attribute::VT_B_ZP, b_zp, 0);
  }
  explicit MATMUL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MATMUL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MATMUL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MATMUL_Attribute> CreateMATMUL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a_zp = 0,
    int32_t b_zp = 0) {
  MATMUL_AttributeBuilder builder_(_fbb);
  builder_.add_b_zp(b_zp);
  builder_.add_a_zp(a_zp);
  return builder_.Finish();
}

struct MAX_POOL2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MAX_POOL2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL = 4,
    VT_STRIDE = 6,
    VT_PAD = 8,
    VT_NAN_MODE = 10
  };
  const ::flatbuffers::Vector<int32_t> *kernel() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KERNEL);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const ::flatbuffers::Vector<int32_t> *pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
  }
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL) &&
           verifier.VerifyVector(kernel()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct MAX_POOL2D_AttributeBuilder {
  typedef MAX_POOL2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kernel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel) {
    fbb_.AddOffset(MAX_POOL2D_Attribute::VT_KERNEL, kernel);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(MAX_POOL2D_Attribute::VT_STRIDE, stride);
  }
  void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad) {
    fbb_.AddOffset(MAX_POOL2D_Attribute::VT_PAD, pad);
  }
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(MAX_POOL2D_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit MAX_POOL2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MAX_POOL2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MAX_POOL2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MAX_POOL2D_Attribute> CreateMAX_POOL2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  MAX_POOL2D_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  builder_.add_pad(pad);
  builder_.add_stride(stride);
  builder_.add_kernel(kernel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MAX_POOL2D_Attribute> CreateMAX_POOL2D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *kernel = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *pad = nullptr,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  auto kernel__ = kernel ? _fbb.CreateVector<int32_t>(*kernel) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
  return tosa::CreateMAX_POOL2D_Attribute(
      _fbb,
      kernel__,
      stride__,
      pad__,
      nan_mode);
}

struct RFFT2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RFFT2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCAL_BOUND = 4
  };
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           verifier.EndTable();
  }
};

struct RFFT2D_AttributeBuilder {
  typedef RFFT2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(RFFT2D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  explicit RFFT2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RFFT2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RFFT2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RFFT2D_Attribute> CreateRFFT2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool local_bound = false) {
  RFFT2D_AttributeBuilder builder_(_fbb);
  builder_.add_local_bound(local_bound);
  return builder_.Finish();
}

struct TRANSPOSE_CONV2D_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRANSPOSE_CONV2D_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_PAD = 4,
    VT_STRIDE = 6,
    VT_INPUT_ZP = 8,
    VT_WEIGHT_ZP = 10,
    VT_LOCAL_BOUND = 12,
    VT_ACC_TYPE = 14
  };
  const ::flatbuffers::Vector<int32_t> *out_pad() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUT_PAD);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t weight_zp() const {
    return GetField<int32_t>(VT_WEIGHT_ZP, 0);
  }
  bool local_bound() const {
    return GetField<uint8_t>(VT_LOCAL_BOUND, 0) != 0;
  }
  tosa::DType acc_type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_ACC_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUT_PAD) &&
           verifier.VerifyVector(out_pad()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) &&
           VerifyField<uint8_t>(verifier, VT_LOCAL_BOUND, 1) &&
           VerifyField<uint32_t>(verifier, VT_ACC_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct TRANSPOSE_CONV2D_AttributeBuilder {
  typedef TRANSPOSE_CONV2D_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> out_pad) {
    fbb_.AddOffset(TRANSPOSE_CONV2D_Attribute::VT_OUT_PAD, out_pad);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(TRANSPOSE_CONV2D_Attribute::VT_STRIDE, stride);
  }
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(TRANSPOSE_CONV2D_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_weight_zp(int32_t weight_zp) {
    fbb_.AddElement<int32_t>(TRANSPOSE_CONV2D_Attribute::VT_WEIGHT_ZP, weight_zp, 0);
  }
  void add_local_bound(bool local_bound) {
    fbb_.AddElement<uint8_t>(TRANSPOSE_CONV2D_Attribute::VT_LOCAL_BOUND, static_cast<uint8_t>(local_bound), 0);
  }
  void add_acc_type(tosa::DType acc_type) {
    fbb_.AddElement<uint32_t>(TRANSPOSE_CONV2D_Attribute::VT_ACC_TYPE, static_cast<uint32_t>(acc_type), 0);
  }
  explicit TRANSPOSE_CONV2D_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRANSPOSE_CONV2D_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRANSPOSE_CONV2D_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRANSPOSE_CONV2D_Attribute> CreateTRANSPOSE_CONV2D_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> out_pad = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  TRANSPOSE_CONV2D_AttributeBuilder builder_(_fbb);
  builder_.add_acc_type(acc_type);
  builder_.add_weight_zp(weight_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_stride(stride);
  builder_.add_out_pad(out_pad);
  builder_.add_local_bound(local_bound);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRANSPOSE_CONV2D_Attribute> CreateTRANSPOSE_CONV2D_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *out_pad = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    int32_t input_zp = 0,
    int32_t weight_zp = 0,
    bool local_bound = false,
    tosa::DType acc_type = tosa::DType_UNKNOWN) {
  auto out_pad__ = out_pad ? _fbb.CreateVector<int32_t>(*out_pad) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return tosa::CreateTRANSPOSE_CONV2D_Attribute(
      _fbb,
      out_pad__,
      stride__,
      input_zp,
      weight_zp,
      local_bound,
      acc_type);
}

struct CLAMP_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CLAMP_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_VAL = 4,
    VT_MAX_VAL = 6,
    VT_NAN_MODE = 8
  };
  const ::flatbuffers::Vector<uint8_t> *min_val() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MIN_VAL);
  }
  const ::flatbuffers::Vector<uint8_t> *max_val() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MAX_VAL);
  }
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_VAL) &&
           verifier.VerifyVector(min_val()) &&
           VerifyOffset(verifier, VT_MAX_VAL) &&
           verifier.VerifyVector(max_val()) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct CLAMP_AttributeBuilder {
  typedef CLAMP_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min_val(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> min_val) {
    fbb_.AddOffset(CLAMP_Attribute::VT_MIN_VAL, min_val);
  }
  void add_max_val(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> max_val) {
    fbb_.AddOffset(CLAMP_Attribute::VT_MAX_VAL, max_val);
  }
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(CLAMP_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit CLAMP_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CLAMP_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CLAMP_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CLAMP_Attribute> CreateCLAMP_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> min_val = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> max_val = 0,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  CLAMP_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CLAMP_Attribute> CreateCLAMP_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *min_val = nullptr,
    const std::vector<uint8_t> *max_val = nullptr,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  if (min_val) { _fbb.ForceVectorAlignment(min_val->size(), sizeof(uint8_t), 8); }
  auto min_val__ = min_val ? _fbb.CreateVector<uint8_t>(*min_val) : 0;
  if (max_val) { _fbb.ForceVectorAlignment(max_val->size(), sizeof(uint8_t), 8); }
  auto max_val__ = max_val ? _fbb.CreateVector<uint8_t>(*max_val) : 0;
  return tosa::CreateCLAMP_Attribute(
      _fbb,
      min_val__,
      max_val__,
      nan_mode);
}

struct ERF_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ERF_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ERF_AttributeBuilder {
  typedef ERF_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ERF_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ERF_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ERF_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ERF_Attribute> CreateERF_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ERF_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SIGMOID_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SIGMOID_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SIGMOID_AttributeBuilder {
  typedef SIGMOID_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SIGMOID_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SIGMOID_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SIGMOID_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SIGMOID_Attribute> CreateSIGMOID_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SIGMOID_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TANH_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TANH_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TANH_AttributeBuilder {
  typedef TANH_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TANH_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TANH_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TANH_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TANH_Attribute> CreateTANH_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TANH_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ADD_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ADD_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ADD_AttributeBuilder {
  typedef ADD_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ADD_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ADD_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ADD_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ADD_Attribute> CreateADD_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ADD_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ARITHMETIC_RIGHT_SHIFT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ARITHMETIC_RIGHT_SHIFT_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUND = 4
  };
  bool round() const {
    return GetField<uint8_t>(VT_ROUND, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ROUND, 1) &&
           verifier.EndTable();
  }
};

struct ARITHMETIC_RIGHT_SHIFT_AttributeBuilder {
  typedef ARITHMETIC_RIGHT_SHIFT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_round(bool round) {
    fbb_.AddElement<uint8_t>(ARITHMETIC_RIGHT_SHIFT_Attribute::VT_ROUND, static_cast<uint8_t>(round), 0);
  }
  explicit ARITHMETIC_RIGHT_SHIFT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ARITHMETIC_RIGHT_SHIFT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ARITHMETIC_RIGHT_SHIFT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ARITHMETIC_RIGHT_SHIFT_Attribute> CreateARITHMETIC_RIGHT_SHIFT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool round = false) {
  ARITHMETIC_RIGHT_SHIFT_AttributeBuilder builder_(_fbb);
  builder_.add_round(round);
  return builder_.Finish();
}

struct BITWISE_AND_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BITWISE_AND_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BITWISE_AND_AttributeBuilder {
  typedef BITWISE_AND_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BITWISE_AND_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BITWISE_AND_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BITWISE_AND_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BITWISE_AND_Attribute> CreateBITWISE_AND_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BITWISE_AND_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BITWISE_OR_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BITWISE_OR_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BITWISE_OR_AttributeBuilder {
  typedef BITWISE_OR_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BITWISE_OR_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BITWISE_OR_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BITWISE_OR_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BITWISE_OR_Attribute> CreateBITWISE_OR_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BITWISE_OR_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BITWISE_XOR_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BITWISE_XOR_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BITWISE_XOR_AttributeBuilder {
  typedef BITWISE_XOR_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BITWISE_XOR_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BITWISE_XOR_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BITWISE_XOR_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BITWISE_XOR_Attribute> CreateBITWISE_XOR_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BITWISE_XOR_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct INTDIV_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef INTDIV_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct INTDIV_AttributeBuilder {
  typedef INTDIV_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit INTDIV_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<INTDIV_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<INTDIV_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<INTDIV_Attribute> CreateINTDIV_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  INTDIV_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_AND_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_AND_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_AND_AttributeBuilder {
  typedef LOGICAL_AND_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_AND_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_AND_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_AND_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_AND_Attribute> CreateLOGICAL_AND_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_AND_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_LEFT_SHIFT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_LEFT_SHIFT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_LEFT_SHIFT_AttributeBuilder {
  typedef LOGICAL_LEFT_SHIFT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_LEFT_SHIFT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_LEFT_SHIFT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_LEFT_SHIFT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_LEFT_SHIFT_Attribute> CreateLOGICAL_LEFT_SHIFT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_LEFT_SHIFT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_RIGHT_SHIFT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_RIGHT_SHIFT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_RIGHT_SHIFT_AttributeBuilder {
  typedef LOGICAL_RIGHT_SHIFT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_RIGHT_SHIFT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_RIGHT_SHIFT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_RIGHT_SHIFT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_RIGHT_SHIFT_Attribute> CreateLOGICAL_RIGHT_SHIFT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_RIGHT_SHIFT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_OR_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_OR_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_OR_AttributeBuilder {
  typedef LOGICAL_OR_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_OR_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_OR_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_OR_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_OR_Attribute> CreateLOGICAL_OR_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_OR_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_XOR_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_XOR_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_XOR_AttributeBuilder {
  typedef LOGICAL_XOR_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_XOR_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_XOR_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_XOR_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_XOR_Attribute> CreateLOGICAL_XOR_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_XOR_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MAXIMUM_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MAXIMUM_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAN_MODE = 4
  };
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct MAXIMUM_AttributeBuilder {
  typedef MAXIMUM_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(MAXIMUM_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit MAXIMUM_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MAXIMUM_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MAXIMUM_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MAXIMUM_Attribute> CreateMAXIMUM_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  MAXIMUM_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  return builder_.Finish();
}

struct MINIMUM_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MINIMUM_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAN_MODE = 4
  };
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct MINIMUM_AttributeBuilder {
  typedef MINIMUM_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(MINIMUM_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit MINIMUM_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MINIMUM_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MINIMUM_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MINIMUM_Attribute> CreateMINIMUM_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  MINIMUM_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  return builder_.Finish();
}

struct MUL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MUL_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHIFT = 4
  };
  int32_t shift() const {
    return GetField<int32_t>(VT_SHIFT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHIFT, 4) &&
           verifier.EndTable();
  }
};

struct MUL_AttributeBuilder {
  typedef MUL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shift(int32_t shift) {
    fbb_.AddElement<int32_t>(MUL_Attribute::VT_SHIFT, shift, 0);
  }
  explicit MUL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MUL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MUL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MUL_Attribute> CreateMUL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shift = 0) {
  MUL_AttributeBuilder builder_(_fbb);
  builder_.add_shift(shift);
  return builder_.Finish();
}

struct POW_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef POW_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct POW_AttributeBuilder {
  typedef POW_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit POW_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<POW_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<POW_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<POW_Attribute> CreatePOW_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  POW_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SUB_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SUB_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SUB_AttributeBuilder {
  typedef SUB_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SUB_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SUB_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SUB_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SUB_Attribute> CreateSUB_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SUB_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TABLE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TABLE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TABLE_AttributeBuilder {
  typedef TABLE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TABLE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TABLE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TABLE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TABLE_Attribute> CreateTABLE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TABLE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ABS_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ABS_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ABS_AttributeBuilder {
  typedef ABS_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ABS_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ABS_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ABS_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ABS_Attribute> CreateABS_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ABS_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BITWISE_NOT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BITWISE_NOT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BITWISE_NOT_AttributeBuilder {
  typedef BITWISE_NOT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BITWISE_NOT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BITWISE_NOT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BITWISE_NOT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BITWISE_NOT_Attribute> CreateBITWISE_NOT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BITWISE_NOT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CEIL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CEIL_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CEIL_AttributeBuilder {
  typedef CEIL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CEIL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CEIL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CEIL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CEIL_Attribute> CreateCEIL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CEIL_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLZ_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CLZ_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CLZ_AttributeBuilder {
  typedef CLZ_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CLZ_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CLZ_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CLZ_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CLZ_Attribute> CreateCLZ_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CLZ_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct COS_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COS_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct COS_AttributeBuilder {
  typedef COS_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit COS_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COS_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COS_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COS_Attribute> CreateCOS_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  COS_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EXP_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EXP_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EXP_AttributeBuilder {
  typedef EXP_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EXP_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EXP_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EXP_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EXP_Attribute> CreateEXP_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EXP_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FLOOR_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FLOOR_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FLOOR_AttributeBuilder {
  typedef FLOOR_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FLOOR_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FLOOR_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FLOOR_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FLOOR_Attribute> CreateFLOOR_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FLOOR_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOG_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOG_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOG_AttributeBuilder {
  typedef LOG_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOG_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOG_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOG_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOG_Attribute> CreateLOG_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOG_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LOGICAL_NOT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LOGICAL_NOT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LOGICAL_NOT_AttributeBuilder {
  typedef LOGICAL_NOT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit LOGICAL_NOT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LOGICAL_NOT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LOGICAL_NOT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LOGICAL_NOT_Attribute> CreateLOGICAL_NOT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  LOGICAL_NOT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NEGATE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NEGATE_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1_ZP = 4,
    VT_OUTPUT_ZP = 6
  };
  int32_t input1_zp() const {
    return GetField<int32_t>(VT_INPUT1_ZP, 0);
  }
  int32_t output_zp() const {
    return GetField<int32_t>(VT_OUTPUT_ZP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUT1_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) &&
           verifier.EndTable();
  }
};

struct NEGATE_AttributeBuilder {
  typedef NEGATE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input1_zp(int32_t input1_zp) {
    fbb_.AddElement<int32_t>(NEGATE_Attribute::VT_INPUT1_ZP, input1_zp, 0);
  }
  void add_output_zp(int32_t output_zp) {
    fbb_.AddElement<int32_t>(NEGATE_Attribute::VT_OUTPUT_ZP, output_zp, 0);
  }
  explicit NEGATE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NEGATE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NEGATE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NEGATE_Attribute> CreateNEGATE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input1_zp = 0,
    int32_t output_zp = 0) {
  NEGATE_AttributeBuilder builder_(_fbb);
  builder_.add_output_zp(output_zp);
  builder_.add_input1_zp(input1_zp);
  return builder_.Finish();
}

struct RECIPROCAL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RECIPROCAL_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RECIPROCAL_AttributeBuilder {
  typedef RECIPROCAL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RECIPROCAL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RECIPROCAL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RECIPROCAL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RECIPROCAL_Attribute> CreateRECIPROCAL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RECIPROCAL_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RSQRT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RSQRT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RSQRT_AttributeBuilder {
  typedef RSQRT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RSQRT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RSQRT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RSQRT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RSQRT_Attribute> CreateRSQRT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RSQRT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SIN_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SIN_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SIN_AttributeBuilder {
  typedef SIN_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SIN_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SIN_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SIN_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SIN_Attribute> CreateSIN_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SIN_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SELECT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SELECT_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SELECT_AttributeBuilder {
  typedef SELECT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SELECT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SELECT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SELECT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SELECT_Attribute> CreateSELECT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SELECT_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EQUAL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EQUAL_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EQUAL_AttributeBuilder {
  typedef EQUAL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EQUAL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EQUAL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EQUAL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EQUAL_Attribute> CreateEQUAL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EQUAL_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GREATER_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GREATER_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GREATER_AttributeBuilder {
  typedef GREATER_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GREATER_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GREATER_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GREATER_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GREATER_Attribute> CreateGREATER_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GREATER_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GREATER_EQUAL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GREATER_EQUAL_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GREATER_EQUAL_AttributeBuilder {
  typedef GREATER_EQUAL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GREATER_EQUAL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GREATER_EQUAL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GREATER_EQUAL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GREATER_EQUAL_Attribute> CreateGREATER_EQUAL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GREATER_EQUAL_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct REDUCE_ALL_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_ALL_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_ALL_AttributeBuilder {
  typedef REDUCE_ALL_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_ALL_Attribute::VT_AXIS, axis, 0);
  }
  explicit REDUCE_ALL_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_ALL_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_ALL_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_ALL_Attribute> CreateREDUCE_ALL_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  REDUCE_ALL_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct REDUCE_ANY_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_ANY_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_ANY_AttributeBuilder {
  typedef REDUCE_ANY_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_ANY_Attribute::VT_AXIS, axis, 0);
  }
  explicit REDUCE_ANY_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_ANY_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_ANY_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_ANY_Attribute> CreateREDUCE_ANY_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  REDUCE_ANY_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct REDUCE_MAX_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_MAX_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_NAN_MODE = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_MAX_AttributeBuilder {
  typedef REDUCE_MAX_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_MAX_Attribute::VT_AXIS, axis, 0);
  }
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(REDUCE_MAX_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit REDUCE_MAX_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_MAX_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_MAX_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_MAX_Attribute> CreateREDUCE_MAX_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  REDUCE_MAX_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct REDUCE_MIN_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_MIN_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_NAN_MODE = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  tosa::NanPropagationMode nan_mode() const {
    return static_cast<tosa::NanPropagationMode>(GetField<uint32_t>(VT_NAN_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NAN_MODE, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_MIN_AttributeBuilder {
  typedef REDUCE_MIN_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_MIN_Attribute::VT_AXIS, axis, 0);
  }
  void add_nan_mode(tosa::NanPropagationMode nan_mode) {
    fbb_.AddElement<uint32_t>(REDUCE_MIN_Attribute::VT_NAN_MODE, static_cast<uint32_t>(nan_mode), 0);
  }
  explicit REDUCE_MIN_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_MIN_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_MIN_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_MIN_Attribute> CreateREDUCE_MIN_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    tosa::NanPropagationMode nan_mode = tosa::NanPropagationMode_UNKNOWN) {
  REDUCE_MIN_AttributeBuilder builder_(_fbb);
  builder_.add_nan_mode(nan_mode);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct REDUCE_PRODUCT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_PRODUCT_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_PRODUCT_AttributeBuilder {
  typedef REDUCE_PRODUCT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_PRODUCT_Attribute::VT_AXIS, axis, 0);
  }
  explicit REDUCE_PRODUCT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_PRODUCT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_PRODUCT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_PRODUCT_Attribute> CreateREDUCE_PRODUCT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  REDUCE_PRODUCT_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct REDUCE_SUM_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REDUCE_SUM_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct REDUCE_SUM_AttributeBuilder {
  typedef REDUCE_SUM_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REDUCE_SUM_Attribute::VT_AXIS, axis, 0);
  }
  explicit REDUCE_SUM_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REDUCE_SUM_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REDUCE_SUM_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REDUCE_SUM_Attribute> CreateREDUCE_SUM_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  REDUCE_SUM_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct CONCAT_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONCAT_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct CONCAT_AttributeBuilder {
  typedef CONCAT_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(CONCAT_Attribute::VT_AXIS, axis, 0);
  }
  explicit CONCAT_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONCAT_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONCAT_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONCAT_Attribute> CreateCONCAT_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  CONCAT_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct PAD_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PAD_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD_CONST = 4
  };
  const ::flatbuffers::Vector<uint8_t> *pad_const() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAD_CONST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAD_CONST) &&
           verifier.VerifyVector(pad_const()) &&
           verifier.EndTable();
  }
};

struct PAD_AttributeBuilder {
  typedef PAD_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pad_const(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pad_const) {
    fbb_.AddOffset(PAD_Attribute::VT_PAD_CONST, pad_const);
  }
  explicit PAD_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PAD_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PAD_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PAD_Attribute> CreatePAD_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pad_const = 0) {
  PAD_AttributeBuilder builder_(_fbb);
  builder_.add_pad_const(pad_const);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PAD_Attribute> CreatePAD_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pad_const = nullptr) {
  if (pad_const) { _fbb.ForceVectorAlignment(pad_const->size(), sizeof(uint8_t), 8); }
  auto pad_const__ = pad_const ? _fbb.CreateVector<uint8_t>(*pad_const) : 0;
  return tosa::CreatePAD_Attribute(
      _fbb,
      pad_const__);
}

struct RESHAPE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RESHAPE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RESHAPE_AttributeBuilder {
  typedef RESHAPE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RESHAPE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RESHAPE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RESHAPE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RESHAPE_Attribute> CreateRESHAPE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RESHAPE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct REVERSE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REVERSE_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct REVERSE_AttributeBuilder {
  typedef REVERSE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(REVERSE_Attribute::VT_AXIS, axis, 0);
  }
  explicit REVERSE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REVERSE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REVERSE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REVERSE_Attribute> CreateREVERSE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  REVERSE_AttributeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SLICE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SLICE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SLICE_AttributeBuilder {
  typedef SLICE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SLICE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SLICE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SLICE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SLICE_Attribute> CreateSLICE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SLICE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TILE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TILE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TILE_AttributeBuilder {
  typedef TILE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit TILE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TILE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TILE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TILE_Attribute> CreateTILE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  TILE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TRANSPOSE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRANSPOSE_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *perms() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PERMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERMS) &&
           verifier.VerifyVector(perms()) &&
           verifier.EndTable();
  }
};

struct TRANSPOSE_AttributeBuilder {
  typedef TRANSPOSE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_perms(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perms) {
    fbb_.AddOffset(TRANSPOSE_Attribute::VT_PERMS, perms);
  }
  explicit TRANSPOSE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRANSPOSE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRANSPOSE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRANSPOSE_Attribute> CreateTRANSPOSE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perms = 0) {
  TRANSPOSE_AttributeBuilder builder_(_fbb);
  builder_.add_perms(perms);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRANSPOSE_Attribute> CreateTRANSPOSE_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *perms = nullptr) {
  auto perms__ = perms ? _fbb.CreateVector<int32_t>(*perms) : 0;
  return tosa::CreateTRANSPOSE_Attribute(
      _fbb,
      perms__);
}

struct GATHER_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GATHER_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GATHER_AttributeBuilder {
  typedef GATHER_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GATHER_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GATHER_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GATHER_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GATHER_Attribute> CreateGATHER_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GATHER_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SCATTER_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SCATTER_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SCATTER_AttributeBuilder {
  typedef SCATTER_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SCATTER_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SCATTER_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SCATTER_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SCATTER_Attribute> CreateSCATTER_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SCATTER_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RESIZE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RESIZE_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  tosa::ResizeMode mode() const {
    return static_cast<tosa::ResizeMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MODE, 4) &&
           verifier.EndTable();
  }
};

struct RESIZE_AttributeBuilder {
  typedef RESIZE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(tosa::ResizeMode mode) {
    fbb_.AddElement<uint32_t>(RESIZE_Attribute::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  explicit RESIZE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RESIZE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RESIZE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RESIZE_Attribute> CreateRESIZE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tosa::ResizeMode mode = tosa::ResizeMode_UNKNOWN) {
  RESIZE_AttributeBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct CAST_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CAST_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CAST_AttributeBuilder {
  typedef CAST_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CAST_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAST_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAST_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CAST_Attribute> CreateCAST_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CAST_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CAST_STOCHASTIC_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CAST_STOCHASTIC_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CAST_STOCHASTIC_AttributeBuilder {
  typedef CAST_STOCHASTIC_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CAST_STOCHASTIC_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAST_STOCHASTIC_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAST_STOCHASTIC_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CAST_STOCHASTIC_Attribute> CreateCAST_STOCHASTIC_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CAST_STOCHASTIC_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RESCALE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RESCALE_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_ZP = 4,
    VT_OUTPUT_ZP = 6,
    VT_SCALE32 = 8,
    VT_DOUBLE_ROUND = 10,
    VT_PER_CHANNEL = 12,
    VT_INPUT_UNSIGNED = 14,
    VT_OUTPUT_UNSIGNED = 16
  };
  int32_t input_zp() const {
    return GetField<int32_t>(VT_INPUT_ZP, 0);
  }
  int32_t output_zp() const {
    return GetField<int32_t>(VT_OUTPUT_ZP, 0);
  }
  bool scale32() const {
    return GetField<uint8_t>(VT_SCALE32, 0) != 0;
  }
  bool double_round() const {
    return GetField<uint8_t>(VT_DOUBLE_ROUND, 0) != 0;
  }
  bool per_channel() const {
    return GetField<uint8_t>(VT_PER_CHANNEL, 0) != 0;
  }
  bool input_unsigned() const {
    return GetField<uint8_t>(VT_INPUT_UNSIGNED, 0) != 0;
  }
  bool output_unsigned() const {
    return GetField<uint8_t>(VT_OUTPUT_UNSIGNED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) &&
           VerifyField<uint8_t>(verifier, VT_SCALE32, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOUBLE_ROUND, 1) &&
           VerifyField<uint8_t>(verifier, VT_PER_CHANNEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_UNSIGNED, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_UNSIGNED, 1) &&
           verifier.EndTable();
  }
};

struct RESCALE_AttributeBuilder {
  typedef RESCALE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_zp(int32_t input_zp) {
    fbb_.AddElement<int32_t>(RESCALE_Attribute::VT_INPUT_ZP, input_zp, 0);
  }
  void add_output_zp(int32_t output_zp) {
    fbb_.AddElement<int32_t>(RESCALE_Attribute::VT_OUTPUT_ZP, output_zp, 0);
  }
  void add_scale32(bool scale32) {
    fbb_.AddElement<uint8_t>(RESCALE_Attribute::VT_SCALE32, static_cast<uint8_t>(scale32), 0);
  }
  void add_double_round(bool double_round) {
    fbb_.AddElement<uint8_t>(RESCALE_Attribute::VT_DOUBLE_ROUND, static_cast<uint8_t>(double_round), 0);
  }
  void add_per_channel(bool per_channel) {
    fbb_.AddElement<uint8_t>(RESCALE_Attribute::VT_PER_CHANNEL, static_cast<uint8_t>(per_channel), 0);
  }
  void add_input_unsigned(bool input_unsigned) {
    fbb_.AddElement<uint8_t>(RESCALE_Attribute::VT_INPUT_UNSIGNED, static_cast<uint8_t>(input_unsigned), 0);
  }
  void add_output_unsigned(bool output_unsigned) {
    fbb_.AddElement<uint8_t>(RESCALE_Attribute::VT_OUTPUT_UNSIGNED, static_cast<uint8_t>(output_unsigned), 0);
  }
  explicit RESCALE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RESCALE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RESCALE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RESCALE_Attribute> CreateRESCALE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input_zp = 0,
    int32_t output_zp = 0,
    bool scale32 = false,
    bool double_round = false,
    bool per_channel = false,
    bool input_unsigned = false,
    bool output_unsigned = false) {
  RESCALE_AttributeBuilder builder_(_fbb);
  builder_.add_output_zp(output_zp);
  builder_.add_input_zp(input_zp);
  builder_.add_output_unsigned(output_unsigned);
  builder_.add_input_unsigned(input_unsigned);
  builder_.add_per_channel(per_channel);
  builder_.add_double_round(double_round);
  builder_.add_scale32(scale32);
  return builder_.Finish();
}

struct CONST_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONST_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CONST_AttributeBuilder {
  typedef CONST_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CONST_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONST_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONST_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONST_Attribute> CreateCONST_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CONST_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RAND_SEED_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RAND_SEED_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RAND_SEED_AttributeBuilder {
  typedef RAND_SEED_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RAND_SEED_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RAND_SEED_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RAND_SEED_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RAND_SEED_Attribute> CreateRAND_SEED_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RAND_SEED_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RAND_UNIFORM_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RAND_UNIFORM_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_SEED = 4
  };
  bool use_seed() const {
    return GetField<uint8_t>(VT_USE_SEED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_SEED, 1) &&
           verifier.EndTable();
  }
};

struct RAND_UNIFORM_AttributeBuilder {
  typedef RAND_UNIFORM_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_use_seed(bool use_seed) {
    fbb_.AddElement<uint8_t>(RAND_UNIFORM_Attribute::VT_USE_SEED, static_cast<uint8_t>(use_seed), 0);
  }
  explicit RAND_UNIFORM_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RAND_UNIFORM_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RAND_UNIFORM_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RAND_UNIFORM_Attribute> CreateRAND_UNIFORM_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool use_seed = false) {
  RAND_UNIFORM_AttributeBuilder builder_(_fbb);
  builder_.add_use_seed(use_seed);
  return builder_.Finish();
}

struct IDENTITY_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IDENTITY_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IDENTITY_AttributeBuilder {
  typedef IDENTITY_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit IDENTITY_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IDENTITY_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IDENTITY_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IDENTITY_Attribute> CreateIDENTITY_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  IDENTITY_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CUSTOM_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CUSTOM_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATOR_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_IMPLEMENTATION_ATTRS = 8
  };
  const ::flatbuffers::String *operator_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATOR_NAME);
  }
  const ::flatbuffers::String *domain_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *implementation_attrs() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTATION_ATTRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPERATOR_NAME) &&
           verifier.VerifyString(operator_name()) &&
           VerifyOffset(verifier, VT_DOMAIN_NAME) &&
           verifier.VerifyString(domain_name()) &&
           VerifyOffset(verifier, VT_IMPLEMENTATION_ATTRS) &&
           verifier.VerifyVector(implementation_attrs()) &&
           verifier.EndTable();
  }
};

struct CUSTOM_AttributeBuilder {
  typedef CUSTOM_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_operator_name(::flatbuffers::Offset<::flatbuffers::String> operator_name) {
    fbb_.AddOffset(CUSTOM_Attribute::VT_OPERATOR_NAME, operator_name);
  }
  void add_domain_name(::flatbuffers::Offset<::flatbuffers::String> domain_name) {
    fbb_.AddOffset(CUSTOM_Attribute::VT_DOMAIN_NAME, domain_name);
  }
  void add_implementation_attrs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implementation_attrs) {
    fbb_.AddOffset(CUSTOM_Attribute::VT_IMPLEMENTATION_ATTRS, implementation_attrs);
  }
  explicit CUSTOM_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CUSTOM_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CUSTOM_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CUSTOM_Attribute> CreateCUSTOM_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> operator_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implementation_attrs = 0) {
  CUSTOM_AttributeBuilder builder_(_fbb);
  builder_.add_implementation_attrs(implementation_attrs);
  builder_.add_domain_name(domain_name);
  builder_.add_operator_name(operator_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CUSTOM_Attribute> CreateCUSTOM_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *operator_name = nullptr,
    const char *domain_name = nullptr,
    const std::vector<uint8_t> *implementation_attrs = nullptr) {
  auto operator_name__ = operator_name ? _fbb.CreateString(operator_name) : 0;
  auto domain_name__ = domain_name ? _fbb.CreateString(domain_name) : 0;
  auto implementation_attrs__ = implementation_attrs ? _fbb.CreateVector<uint8_t>(*implementation_attrs) : 0;
  return tosa::CreateCUSTOM_Attribute(
      _fbb,
      operator_name__,
      domain_name__,
      implementation_attrs__);
}

struct COND_IF_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COND_IF_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_GRAPH = 4,
    VT_ELSE_GRAPH = 6
  };
  const ::flatbuffers::String *then_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THEN_GRAPH);
  }
  const ::flatbuffers::String *else_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELSE_GRAPH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THEN_GRAPH) &&
           verifier.VerifyString(then_graph()) &&
           VerifyOffset(verifier, VT_ELSE_GRAPH) &&
           verifier.VerifyString(else_graph()) &&
           verifier.EndTable();
  }
};

struct COND_IF_AttributeBuilder {
  typedef COND_IF_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_then_graph(::flatbuffers::Offset<::flatbuffers::String> then_graph) {
    fbb_.AddOffset(COND_IF_Attribute::VT_THEN_GRAPH, then_graph);
  }
  void add_else_graph(::flatbuffers::Offset<::flatbuffers::String> else_graph) {
    fbb_.AddOffset(COND_IF_Attribute::VT_ELSE_GRAPH, else_graph);
  }
  explicit COND_IF_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COND_IF_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COND_IF_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COND_IF_Attribute> CreateCOND_IF_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> then_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::String> else_graph = 0) {
  COND_IF_AttributeBuilder builder_(_fbb);
  builder_.add_else_graph(else_graph);
  builder_.add_then_graph(then_graph);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<COND_IF_Attribute> CreateCOND_IF_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *then_graph = nullptr,
    const char *else_graph = nullptr) {
  auto then_graph__ = then_graph ? _fbb.CreateString(then_graph) : 0;
  auto else_graph__ = else_graph ? _fbb.CreateString(else_graph) : 0;
  return tosa::CreateCOND_IF_Attribute(
      _fbb,
      then_graph__,
      else_graph__);
}

struct WHILE_LOOP_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WHILE_LOOP_AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_GRAPH = 4,
    VT_BODY_GRAPH = 6
  };
  const ::flatbuffers::String *cond_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COND_GRAPH);
  }
  const ::flatbuffers::String *body_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BODY_GRAPH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COND_GRAPH) &&
           verifier.VerifyString(cond_graph()) &&
           VerifyOffset(verifier, VT_BODY_GRAPH) &&
           verifier.VerifyString(body_graph()) &&
           verifier.EndTable();
  }
};

struct WHILE_LOOP_AttributeBuilder {
  typedef WHILE_LOOP_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_graph(::flatbuffers::Offset<::flatbuffers::String> cond_graph) {
    fbb_.AddOffset(WHILE_LOOP_Attribute::VT_COND_GRAPH, cond_graph);
  }
  void add_body_graph(::flatbuffers::Offset<::flatbuffers::String> body_graph) {
    fbb_.AddOffset(WHILE_LOOP_Attribute::VT_BODY_GRAPH, body_graph);
  }
  explicit WHILE_LOOP_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WHILE_LOOP_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WHILE_LOOP_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WHILE_LOOP_Attribute> CreateWHILE_LOOP_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cond_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::String> body_graph = 0) {
  WHILE_LOOP_AttributeBuilder builder_(_fbb);
  builder_.add_body_graph(body_graph);
  builder_.add_cond_graph(cond_graph);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WHILE_LOOP_Attribute> CreateWHILE_LOOP_AttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cond_graph = nullptr,
    const char *body_graph = nullptr) {
  auto cond_graph__ = cond_graph ? _fbb.CreateString(cond_graph) : 0;
  auto body_graph__ = body_graph ? _fbb.CreateString(body_graph) : 0;
  return tosa::CreateWHILE_LOOP_Attribute(
      _fbb,
      cond_graph__,
      body_graph__);
}

struct YIELD_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YIELD_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct YIELD_AttributeBuilder {
  typedef YIELD_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit YIELD_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<YIELD_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<YIELD_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<YIELD_Attribute> CreateYIELD_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  YIELD_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VARIABLE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VARIABLE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VARIABLE_AttributeBuilder {
  typedef VARIABLE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit VARIABLE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VARIABLE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VARIABLE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VARIABLE_Attribute> CreateVARIABLE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  VARIABLE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VARIABLE_WRITE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VARIABLE_WRITE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VARIABLE_WRITE_AttributeBuilder {
  typedef VARIABLE_WRITE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit VARIABLE_WRITE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VARIABLE_WRITE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VARIABLE_WRITE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VARIABLE_WRITE_Attribute> CreateVARIABLE_WRITE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  VARIABLE_WRITE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VARIABLE_READ_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VARIABLE_READ_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VARIABLE_READ_AttributeBuilder {
  typedef VARIABLE_READ_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit VARIABLE_READ_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VARIABLE_READ_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VARIABLE_READ_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VARIABLE_READ_Attribute> CreateVARIABLE_READ_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  VARIABLE_READ_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CONST_SHAPE_Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONST_SHAPE_AttributeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CONST_SHAPE_AttributeBuilder {
  typedef CONST_SHAPE_Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CONST_SHAPE_AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONST_SHAPE_Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONST_SHAPE_Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONST_SHAPE_Attribute> CreateCONST_SHAPE_Attribute(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CONST_SHAPE_AttributeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Version FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VersionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__MAJOR = 4,
    VT__MINOR = 6,
    VT__PATCH = 8,
    VT__DRAFT = 10
  };
  int32_t _major() const {
    return GetField<int32_t>(VT__MAJOR, -1);
  }
  int32_t _minor() const {
    return GetField<int32_t>(VT__MINOR, -1);
  }
  int32_t _patch() const {
    return GetField<int32_t>(VT__PATCH, -1);
  }
  bool _draft() const {
    return GetField<uint8_t>(VT__DRAFT, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT__MAJOR, 4) &&
           VerifyField<int32_t>(verifier, VT__MINOR, 4) &&
           VerifyField<int32_t>(verifier, VT__PATCH, 4) &&
           VerifyField<uint8_t>(verifier, VT__DRAFT, 1) &&
           verifier.EndTable();
  }
};

struct VersionBuilder {
  typedef Version Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add__major(int32_t _major) {
    fbb_.AddElement<int32_t>(Version::VT__MAJOR, _major, -1);
  }
  void add__minor(int32_t _minor) {
    fbb_.AddElement<int32_t>(Version::VT__MINOR, _minor, -1);
  }
  void add__patch(int32_t _patch) {
    fbb_.AddElement<int32_t>(Version::VT__PATCH, _patch, -1);
  }
  void add__draft(bool _draft) {
    fbb_.AddElement<uint8_t>(Version::VT__DRAFT, static_cast<uint8_t>(_draft), 1);
  }
  explicit VersionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Version> CreateVersion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t _major = -1,
    int32_t _minor = -1,
    int32_t _patch = -1,
    bool _draft = true) {
  VersionBuilder builder_(_fbb);
  builder_.add__patch(_patch);
  builder_.add__minor(_minor);
  builder_.add__major(_major);
  builder_.add__draft(_draft);
  return builder_.Finish();
}

struct TosaTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TosaTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHAPE = 6,
    VT_TYPE = 8,
    VT_DATA = 10,
    VT_VARIABLE = 12,
    VT_IS_UNRANKED = 14,
    VT_VARIABLE_NAME = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  tosa::DType type() const {
    return static_cast<tosa::DType>(GetField<uint32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool variable() const {
    return GetField<uint8_t>(VT_VARIABLE, 0) != 0;
  }
  bool is_unranked() const {
    return GetField<uint8_t>(VT_IS_UNRANKED, 0) != 0;
  }
  const ::flatbuffers::String *variable_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VARIABLE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_VARIABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_UNRANKED, 1) &&
           VerifyOffset(verifier, VT_VARIABLE_NAME) &&
           verifier.VerifyString(variable_name()) &&
           verifier.EndTable();
  }
};

struct TosaTensorBuilder {
  typedef TosaTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TosaTensor::VT_NAME, name);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(TosaTensor::VT_SHAPE, shape);
  }
  void add_type(tosa::DType type) {
    fbb_.AddElement<uint32_t>(TosaTensor::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(TosaTensor::VT_DATA, data);
  }
  void add_variable(bool variable) {
    fbb_.AddElement<uint8_t>(TosaTensor::VT_VARIABLE, static_cast<uint8_t>(variable), 0);
  }
  void add_is_unranked(bool is_unranked) {
    fbb_.AddElement<uint8_t>(TosaTensor::VT_IS_UNRANKED, static_cast<uint8_t>(is_unranked), 0);
  }
  void add_variable_name(::flatbuffers::Offset<::flatbuffers::String> variable_name) {
    fbb_.AddOffset(TosaTensor::VT_VARIABLE_NAME, variable_name);
  }
  explicit TosaTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TosaTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TosaTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TosaTensor> CreateTosaTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    tosa::DType type = tosa::DType_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    bool variable = false,
    bool is_unranked = false,
    ::flatbuffers::Offset<::flatbuffers::String> variable_name = 0) {
  TosaTensorBuilder builder_(_fbb);
  builder_.add_variable_name(variable_name);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_shape(shape);
  builder_.add_name(name);
  builder_.add_is_unranked(is_unranked);
  builder_.add_variable(variable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaTensor> CreateTosaTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    tosa::DType type = tosa::DType_UNKNOWN,
    const std::vector<uint8_t> *data = nullptr,
    bool variable = false,
    bool is_unranked = false,
    const char *variable_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 8); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto variable_name__ = variable_name ? _fbb.CreateString(variable_name) : 0;
  return tosa::CreateTosaTensor(
      _fbb,
      name__,
      shape__,
      type,
      data__,
      variable,
      is_unranked,
      variable_name__);
}

struct TosaOperator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TosaOperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_ATTRIBUTE_TYPE = 6,
    VT_ATTRIBUTE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12
  };
  tosa::Op op() const {
    return static_cast<tosa::Op>(GetField<uint32_t>(VT_OP, 0));
  }
  tosa::Attribute attribute_type() const {
    return static_cast<tosa::Attribute>(GetField<uint8_t>(VT_ATTRIBUTE_TYPE, 0));
  }
  const void *attribute() const {
    return GetPointer<const void *>(VT_ATTRIBUTE);
  }
  template<typename T> const T *attribute_as() const;
  const tosa::ARGMAX_Attribute *attribute_as_ARGMAX_Attribute() const {
    return attribute_type() == tosa::Attribute_ARGMAX_Attribute ? static_cast<const tosa::ARGMAX_Attribute *>(attribute()) : nullptr;
  }
  const tosa::AVG_POOL2D_Attribute *attribute_as_AVG_POOL2D_Attribute() const {
    return attribute_type() == tosa::Attribute_AVG_POOL2D_Attribute ? static_cast<const tosa::AVG_POOL2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CONV2D_Attribute *attribute_as_CONV2D_Attribute() const {
    return attribute_type() == tosa::Attribute_CONV2D_Attribute ? static_cast<const tosa::CONV2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CONV3D_Attribute *attribute_as_CONV3D_Attribute() const {
    return attribute_type() == tosa::Attribute_CONV3D_Attribute ? static_cast<const tosa::CONV3D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::DEPTHWISE_CONV2D_Attribute *attribute_as_DEPTHWISE_CONV2D_Attribute() const {
    return attribute_type() == tosa::Attribute_DEPTHWISE_CONV2D_Attribute ? static_cast<const tosa::DEPTHWISE_CONV2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::FFT2D_Attribute *attribute_as_FFT2D_Attribute() const {
    return attribute_type() == tosa::Attribute_FFT2D_Attribute ? static_cast<const tosa::FFT2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::MATMUL_Attribute *attribute_as_MATMUL_Attribute() const {
    return attribute_type() == tosa::Attribute_MATMUL_Attribute ? static_cast<const tosa::MATMUL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::MAX_POOL2D_Attribute *attribute_as_MAX_POOL2D_Attribute() const {
    return attribute_type() == tosa::Attribute_MAX_POOL2D_Attribute ? static_cast<const tosa::MAX_POOL2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RFFT2D_Attribute *attribute_as_RFFT2D_Attribute() const {
    return attribute_type() == tosa::Attribute_RFFT2D_Attribute ? static_cast<const tosa::RFFT2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::TRANSPOSE_CONV2D_Attribute *attribute_as_TRANSPOSE_CONV2D_Attribute() const {
    return attribute_type() == tosa::Attribute_TRANSPOSE_CONV2D_Attribute ? static_cast<const tosa::TRANSPOSE_CONV2D_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CLAMP_Attribute *attribute_as_CLAMP_Attribute() const {
    return attribute_type() == tosa::Attribute_CLAMP_Attribute ? static_cast<const tosa::CLAMP_Attribute *>(attribute()) : nullptr;
  }
  const tosa::ERF_Attribute *attribute_as_ERF_Attribute() const {
    return attribute_type() == tosa::Attribute_ERF_Attribute ? static_cast<const tosa::ERF_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SIGMOID_Attribute *attribute_as_SIGMOID_Attribute() const {
    return attribute_type() == tosa::Attribute_SIGMOID_Attribute ? static_cast<const tosa::SIGMOID_Attribute *>(attribute()) : nullptr;
  }
  const tosa::TANH_Attribute *attribute_as_TANH_Attribute() const {
    return attribute_type() == tosa::Attribute_TANH_Attribute ? static_cast<const tosa::TANH_Attribute *>(attribute()) : nullptr;
  }
  const tosa::ADD_Attribute *attribute_as_ADD_Attribute() const {
    return attribute_type() == tosa::Attribute_ADD_Attribute ? static_cast<const tosa::ADD_Attribute *>(attribute()) : nullptr;
  }
  const tosa::ARITHMETIC_RIGHT_SHIFT_Attribute *attribute_as_ARITHMETIC_RIGHT_SHIFT_Attribute() const {
    return attribute_type() == tosa::Attribute_ARITHMETIC_RIGHT_SHIFT_Attribute ? static_cast<const tosa::ARITHMETIC_RIGHT_SHIFT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::BITWISE_AND_Attribute *attribute_as_BITWISE_AND_Attribute() const {
    return attribute_type() == tosa::Attribute_BITWISE_AND_Attribute ? static_cast<const tosa::BITWISE_AND_Attribute *>(attribute()) : nullptr;
  }
  const tosa::BITWISE_OR_Attribute *attribute_as_BITWISE_OR_Attribute() const {
    return attribute_type() == tosa::Attribute_BITWISE_OR_Attribute ? static_cast<const tosa::BITWISE_OR_Attribute *>(attribute()) : nullptr;
  }
  const tosa::BITWISE_XOR_Attribute *attribute_as_BITWISE_XOR_Attribute() const {
    return attribute_type() == tosa::Attribute_BITWISE_XOR_Attribute ? static_cast<const tosa::BITWISE_XOR_Attribute *>(attribute()) : nullptr;
  }
  const tosa::INTDIV_Attribute *attribute_as_INTDIV_Attribute() const {
    return attribute_type() == tosa::Attribute_INTDIV_Attribute ? static_cast<const tosa::INTDIV_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_AND_Attribute *attribute_as_LOGICAL_AND_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_AND_Attribute ? static_cast<const tosa::LOGICAL_AND_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_LEFT_SHIFT_Attribute *attribute_as_LOGICAL_LEFT_SHIFT_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_LEFT_SHIFT_Attribute ? static_cast<const tosa::LOGICAL_LEFT_SHIFT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_RIGHT_SHIFT_Attribute *attribute_as_LOGICAL_RIGHT_SHIFT_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_RIGHT_SHIFT_Attribute ? static_cast<const tosa::LOGICAL_RIGHT_SHIFT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_OR_Attribute *attribute_as_LOGICAL_OR_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_OR_Attribute ? static_cast<const tosa::LOGICAL_OR_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_XOR_Attribute *attribute_as_LOGICAL_XOR_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_XOR_Attribute ? static_cast<const tosa::LOGICAL_XOR_Attribute *>(attribute()) : nullptr;
  }
  const tosa::MAXIMUM_Attribute *attribute_as_MAXIMUM_Attribute() const {
    return attribute_type() == tosa::Attribute_MAXIMUM_Attribute ? static_cast<const tosa::MAXIMUM_Attribute *>(attribute()) : nullptr;
  }
  const tosa::MINIMUM_Attribute *attribute_as_MINIMUM_Attribute() const {
    return attribute_type() == tosa::Attribute_MINIMUM_Attribute ? static_cast<const tosa::MINIMUM_Attribute *>(attribute()) : nullptr;
  }
  const tosa::MUL_Attribute *attribute_as_MUL_Attribute() const {
    return attribute_type() == tosa::Attribute_MUL_Attribute ? static_cast<const tosa::MUL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::POW_Attribute *attribute_as_POW_Attribute() const {
    return attribute_type() == tosa::Attribute_POW_Attribute ? static_cast<const tosa::POW_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SUB_Attribute *attribute_as_SUB_Attribute() const {
    return attribute_type() == tosa::Attribute_SUB_Attribute ? static_cast<const tosa::SUB_Attribute *>(attribute()) : nullptr;
  }
  const tosa::TABLE_Attribute *attribute_as_TABLE_Attribute() const {
    return attribute_type() == tosa::Attribute_TABLE_Attribute ? static_cast<const tosa::TABLE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::ABS_Attribute *attribute_as_ABS_Attribute() const {
    return attribute_type() == tosa::Attribute_ABS_Attribute ? static_cast<const tosa::ABS_Attribute *>(attribute()) : nullptr;
  }
  const tosa::BITWISE_NOT_Attribute *attribute_as_BITWISE_NOT_Attribute() const {
    return attribute_type() == tosa::Attribute_BITWISE_NOT_Attribute ? static_cast<const tosa::BITWISE_NOT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CEIL_Attribute *attribute_as_CEIL_Attribute() const {
    return attribute_type() == tosa::Attribute_CEIL_Attribute ? static_cast<const tosa::CEIL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CLZ_Attribute *attribute_as_CLZ_Attribute() const {
    return attribute_type() == tosa::Attribute_CLZ_Attribute ? static_cast<const tosa::CLZ_Attribute *>(attribute()) : nullptr;
  }
  const tosa::COS_Attribute *attribute_as_COS_Attribute() const {
    return attribute_type() == tosa::Attribute_COS_Attribute ? static_cast<const tosa::COS_Attribute *>(attribute()) : nullptr;
  }
  const tosa::EXP_Attribute *attribute_as_EXP_Attribute() const {
    return attribute_type() == tosa::Attribute_EXP_Attribute ? static_cast<const tosa::EXP_Attribute *>(attribute()) : nullptr;
  }
  const tosa::FLOOR_Attribute *attribute_as_FLOOR_Attribute() const {
    return attribute_type() == tosa::Attribute_FLOOR_Attribute ? static_cast<const tosa::FLOOR_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOG_Attribute *attribute_as_LOG_Attribute() const {
    return attribute_type() == tosa::Attribute_LOG_Attribute ? static_cast<const tosa::LOG_Attribute *>(attribute()) : nullptr;
  }
  const tosa::LOGICAL_NOT_Attribute *attribute_as_LOGICAL_NOT_Attribute() const {
    return attribute_type() == tosa::Attribute_LOGICAL_NOT_Attribute ? static_cast<const tosa::LOGICAL_NOT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::NEGATE_Attribute *attribute_as_NEGATE_Attribute() const {
    return attribute_type() == tosa::Attribute_NEGATE_Attribute ? static_cast<const tosa::NEGATE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RECIPROCAL_Attribute *attribute_as_RECIPROCAL_Attribute() const {
    return attribute_type() == tosa::Attribute_RECIPROCAL_Attribute ? static_cast<const tosa::RECIPROCAL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RSQRT_Attribute *attribute_as_RSQRT_Attribute() const {
    return attribute_type() == tosa::Attribute_RSQRT_Attribute ? static_cast<const tosa::RSQRT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SIN_Attribute *attribute_as_SIN_Attribute() const {
    return attribute_type() == tosa::Attribute_SIN_Attribute ? static_cast<const tosa::SIN_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SELECT_Attribute *attribute_as_SELECT_Attribute() const {
    return attribute_type() == tosa::Attribute_SELECT_Attribute ? static_cast<const tosa::SELECT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::EQUAL_Attribute *attribute_as_EQUAL_Attribute() const {
    return attribute_type() == tosa::Attribute_EQUAL_Attribute ? static_cast<const tosa::EQUAL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::GREATER_Attribute *attribute_as_GREATER_Attribute() const {
    return attribute_type() == tosa::Attribute_GREATER_Attribute ? static_cast<const tosa::GREATER_Attribute *>(attribute()) : nullptr;
  }
  const tosa::GREATER_EQUAL_Attribute *attribute_as_GREATER_EQUAL_Attribute() const {
    return attribute_type() == tosa::Attribute_GREATER_EQUAL_Attribute ? static_cast<const tosa::GREATER_EQUAL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_ALL_Attribute *attribute_as_REDUCE_ALL_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_ALL_Attribute ? static_cast<const tosa::REDUCE_ALL_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_ANY_Attribute *attribute_as_REDUCE_ANY_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_ANY_Attribute ? static_cast<const tosa::REDUCE_ANY_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_MAX_Attribute *attribute_as_REDUCE_MAX_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_MAX_Attribute ? static_cast<const tosa::REDUCE_MAX_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_MIN_Attribute *attribute_as_REDUCE_MIN_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_MIN_Attribute ? static_cast<const tosa::REDUCE_MIN_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_PRODUCT_Attribute *attribute_as_REDUCE_PRODUCT_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_PRODUCT_Attribute ? static_cast<const tosa::REDUCE_PRODUCT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REDUCE_SUM_Attribute *attribute_as_REDUCE_SUM_Attribute() const {
    return attribute_type() == tosa::Attribute_REDUCE_SUM_Attribute ? static_cast<const tosa::REDUCE_SUM_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CONCAT_Attribute *attribute_as_CONCAT_Attribute() const {
    return attribute_type() == tosa::Attribute_CONCAT_Attribute ? static_cast<const tosa::CONCAT_Attribute *>(attribute()) : nullptr;
  }
  const tosa::PAD_Attribute *attribute_as_PAD_Attribute() const {
    return attribute_type() == tosa::Attribute_PAD_Attribute ? static_cast<const tosa::PAD_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RESHAPE_Attribute *attribute_as_RESHAPE_Attribute() const {
    return attribute_type() == tosa::Attribute_RESHAPE_Attribute ? static_cast<const tosa::RESHAPE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::REVERSE_Attribute *attribute_as_REVERSE_Attribute() const {
    return attribute_type() == tosa::Attribute_REVERSE_Attribute ? static_cast<const tosa::REVERSE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SLICE_Attribute *attribute_as_SLICE_Attribute() const {
    return attribute_type() == tosa::Attribute_SLICE_Attribute ? static_cast<const tosa::SLICE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::TILE_Attribute *attribute_as_TILE_Attribute() const {
    return attribute_type() == tosa::Attribute_TILE_Attribute ? static_cast<const tosa::TILE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::TRANSPOSE_Attribute *attribute_as_TRANSPOSE_Attribute() const {
    return attribute_type() == tosa::Attribute_TRANSPOSE_Attribute ? static_cast<const tosa::TRANSPOSE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::GATHER_Attribute *attribute_as_GATHER_Attribute() const {
    return attribute_type() == tosa::Attribute_GATHER_Attribute ? static_cast<const tosa::GATHER_Attribute *>(attribute()) : nullptr;
  }
  const tosa::SCATTER_Attribute *attribute_as_SCATTER_Attribute() const {
    return attribute_type() == tosa::Attribute_SCATTER_Attribute ? static_cast<const tosa::SCATTER_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RESIZE_Attribute *attribute_as_RESIZE_Attribute() const {
    return attribute_type() == tosa::Attribute_RESIZE_Attribute ? static_cast<const tosa::RESIZE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CAST_Attribute *attribute_as_CAST_Attribute() const {
    return attribute_type() == tosa::Attribute_CAST_Attribute ? static_cast<const tosa::CAST_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CAST_STOCHASTIC_Attribute *attribute_as_CAST_STOCHASTIC_Attribute() const {
    return attribute_type() == tosa::Attribute_CAST_STOCHASTIC_Attribute ? static_cast<const tosa::CAST_STOCHASTIC_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RESCALE_Attribute *attribute_as_RESCALE_Attribute() const {
    return attribute_type() == tosa::Attribute_RESCALE_Attribute ? static_cast<const tosa::RESCALE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CONST_Attribute *attribute_as_CONST_Attribute() const {
    return attribute_type() == tosa::Attribute_CONST_Attribute ? static_cast<const tosa::CONST_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RAND_SEED_Attribute *attribute_as_RAND_SEED_Attribute() const {
    return attribute_type() == tosa::Attribute_RAND_SEED_Attribute ? static_cast<const tosa::RAND_SEED_Attribute *>(attribute()) : nullptr;
  }
  const tosa::RAND_UNIFORM_Attribute *attribute_as_RAND_UNIFORM_Attribute() const {
    return attribute_type() == tosa::Attribute_RAND_UNIFORM_Attribute ? static_cast<const tosa::RAND_UNIFORM_Attribute *>(attribute()) : nullptr;
  }
  const tosa::IDENTITY_Attribute *attribute_as_IDENTITY_Attribute() const {
    return attribute_type() == tosa::Attribute_IDENTITY_Attribute ? static_cast<const tosa::IDENTITY_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CUSTOM_Attribute *attribute_as_CUSTOM_Attribute() const {
    return attribute_type() == tosa::Attribute_CUSTOM_Attribute ? static_cast<const tosa::CUSTOM_Attribute *>(attribute()) : nullptr;
  }
  const tosa::COND_IF_Attribute *attribute_as_COND_IF_Attribute() const {
    return attribute_type() == tosa::Attribute_COND_IF_Attribute ? static_cast<const tosa::COND_IF_Attribute *>(attribute()) : nullptr;
  }
  const tosa::WHILE_LOOP_Attribute *attribute_as_WHILE_LOOP_Attribute() const {
    return attribute_type() == tosa::Attribute_WHILE_LOOP_Attribute ? static_cast<const tosa::WHILE_LOOP_Attribute *>(attribute()) : nullptr;
  }
  const tosa::YIELD_Attribute *attribute_as_YIELD_Attribute() const {
    return attribute_type() == tosa::Attribute_YIELD_Attribute ? static_cast<const tosa::YIELD_Attribute *>(attribute()) : nullptr;
  }
  const tosa::VARIABLE_Attribute *attribute_as_VARIABLE_Attribute() const {
    return attribute_type() == tosa::Attribute_VARIABLE_Attribute ? static_cast<const tosa::VARIABLE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::VARIABLE_WRITE_Attribute *attribute_as_VARIABLE_WRITE_Attribute() const {
    return attribute_type() == tosa::Attribute_VARIABLE_WRITE_Attribute ? static_cast<const tosa::VARIABLE_WRITE_Attribute *>(attribute()) : nullptr;
  }
  const tosa::VARIABLE_READ_Attribute *attribute_as_VARIABLE_READ_Attribute() const {
    return attribute_type() == tosa::Attribute_VARIABLE_READ_Attribute ? static_cast<const tosa::VARIABLE_READ_Attribute *>(attribute()) : nullptr;
  }
  const tosa::CONST_SHAPE_Attribute *attribute_as_CONST_SHAPE_Attribute() const {
    return attribute_type() == tosa::Attribute_CONST_SHAPE_Attribute ? static_cast<const tosa::CONST_SHAPE_Attribute *>(attribute()) : nullptr;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OP, 4) &&
           VerifyField<uint8_t>(verifier, VT_ATTRIBUTE_TYPE, 1) &&
           VerifyOffset(verifier, VT_ATTRIBUTE) &&
           VerifyAttribute(verifier, attribute(), attribute_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

template<> inline const tosa::ARGMAX_Attribute *TosaOperator::attribute_as<tosa::ARGMAX_Attribute>() const {
  return attribute_as_ARGMAX_Attribute();
}

template<> inline const tosa::AVG_POOL2D_Attribute *TosaOperator::attribute_as<tosa::AVG_POOL2D_Attribute>() const {
  return attribute_as_AVG_POOL2D_Attribute();
}

template<> inline const tosa::CONV2D_Attribute *TosaOperator::attribute_as<tosa::CONV2D_Attribute>() const {
  return attribute_as_CONV2D_Attribute();
}

template<> inline const tosa::CONV3D_Attribute *TosaOperator::attribute_as<tosa::CONV3D_Attribute>() const {
  return attribute_as_CONV3D_Attribute();
}

template<> inline const tosa::DEPTHWISE_CONV2D_Attribute *TosaOperator::attribute_as<tosa::DEPTHWISE_CONV2D_Attribute>() const {
  return attribute_as_DEPTHWISE_CONV2D_Attribute();
}

template<> inline const tosa::FFT2D_Attribute *TosaOperator::attribute_as<tosa::FFT2D_Attribute>() const {
  return attribute_as_FFT2D_Attribute();
}

template<> inline const tosa::MATMUL_Attribute *TosaOperator::attribute_as<tosa::MATMUL_Attribute>() const {
  return attribute_as_MATMUL_Attribute();
}

template<> inline const tosa::MAX_POOL2D_Attribute *TosaOperator::attribute_as<tosa::MAX_POOL2D_Attribute>() const {
  return attribute_as_MAX_POOL2D_Attribute();
}

template<> inline const tosa::RFFT2D_Attribute *TosaOperator::attribute_as<tosa::RFFT2D_Attribute>() const {
  return attribute_as_RFFT2D_Attribute();
}

template<> inline const tosa::TRANSPOSE_CONV2D_Attribute *TosaOperator::attribute_as<tosa::TRANSPOSE_CONV2D_Attribute>() const {
  return attribute_as_TRANSPOSE_CONV2D_Attribute();
}

template<> inline const tosa::CLAMP_Attribute *TosaOperator::attribute_as<tosa::CLAMP_Attribute>() const {
  return attribute_as_CLAMP_Attribute();
}

template<> inline const tosa::ERF_Attribute *TosaOperator::attribute_as<tosa::ERF_Attribute>() const {
  return attribute_as_ERF_Attribute();
}

template<> inline const tosa::SIGMOID_Attribute *TosaOperator::attribute_as<tosa::SIGMOID_Attribute>() const {
  return attribute_as_SIGMOID_Attribute();
}

template<> inline const tosa::TANH_Attribute *TosaOperator::attribute_as<tosa::TANH_Attribute>() const {
  return attribute_as_TANH_Attribute();
}

template<> inline const tosa::ADD_Attribute *TosaOperator::attribute_as<tosa::ADD_Attribute>() const {
  return attribute_as_ADD_Attribute();
}

template<> inline const tosa::ARITHMETIC_RIGHT_SHIFT_Attribute *TosaOperator::attribute_as<tosa::ARITHMETIC_RIGHT_SHIFT_Attribute>() const {
  return attribute_as_ARITHMETIC_RIGHT_SHIFT_Attribute();
}

template<> inline const tosa::BITWISE_AND_Attribute *TosaOperator::attribute_as<tosa::BITWISE_AND_Attribute>() const {
  return attribute_as_BITWISE_AND_Attribute();
}

template<> inline const tosa::BITWISE_OR_Attribute *TosaOperator::attribute_as<tosa::BITWISE_OR_Attribute>() const {
  return attribute_as_BITWISE_OR_Attribute();
}

template<> inline const tosa::BITWISE_XOR_Attribute *TosaOperator::attribute_as<tosa::BITWISE_XOR_Attribute>() const {
  return attribute_as_BITWISE_XOR_Attribute();
}

template<> inline const tosa::INTDIV_Attribute *TosaOperator::attribute_as<tosa::INTDIV_Attribute>() const {
  return attribute_as_INTDIV_Attribute();
}

template<> inline const tosa::LOGICAL_AND_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_AND_Attribute>() const {
  return attribute_as_LOGICAL_AND_Attribute();
}

template<> inline const tosa::LOGICAL_LEFT_SHIFT_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_LEFT_SHIFT_Attribute>() const {
  return attribute_as_LOGICAL_LEFT_SHIFT_Attribute();
}

template<> inline const tosa::LOGICAL_RIGHT_SHIFT_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_RIGHT_SHIFT_Attribute>() const {
  return attribute_as_LOGICAL_RIGHT_SHIFT_Attribute();
}

template<> inline const tosa::LOGICAL_OR_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_OR_Attribute>() const {
  return attribute_as_LOGICAL_OR_Attribute();
}

template<> inline const tosa::LOGICAL_XOR_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_XOR_Attribute>() const {
  return attribute_as_LOGICAL_XOR_Attribute();
}

template<> inline const tosa::MAXIMUM_Attribute *TosaOperator::attribute_as<tosa::MAXIMUM_Attribute>() const {
  return attribute_as_MAXIMUM_Attribute();
}

template<> inline const tosa::MINIMUM_Attribute *TosaOperator::attribute_as<tosa::MINIMUM_Attribute>() const {
  return attribute_as_MINIMUM_Attribute();
}

template<> inline const tosa::MUL_Attribute *TosaOperator::attribute_as<tosa::MUL_Attribute>() const {
  return attribute_as_MUL_Attribute();
}

template<> inline const tosa::POW_Attribute *TosaOperator::attribute_as<tosa::POW_Attribute>() const {
  return attribute_as_POW_Attribute();
}

template<> inline const tosa::SUB_Attribute *TosaOperator::attribute_as<tosa::SUB_Attribute>() const {
  return attribute_as_SUB_Attribute();
}

template<> inline const tosa::TABLE_Attribute *TosaOperator::attribute_as<tosa::TABLE_Attribute>() const {
  return attribute_as_TABLE_Attribute();
}

template<> inline const tosa::ABS_Attribute *TosaOperator::attribute_as<tosa::ABS_Attribute>() const {
  return attribute_as_ABS_Attribute();
}

template<> inline const tosa::BITWISE_NOT_Attribute *TosaOperator::attribute_as<tosa::BITWISE_NOT_Attribute>() const {
  return attribute_as_BITWISE_NOT_Attribute();
}

template<> inline const tosa::CEIL_Attribute *TosaOperator::attribute_as<tosa::CEIL_Attribute>() const {
  return attribute_as_CEIL_Attribute();
}

template<> inline const tosa::CLZ_Attribute *TosaOperator::attribute_as<tosa::CLZ_Attribute>() const {
  return attribute_as_CLZ_Attribute();
}

template<> inline const tosa::COS_Attribute *TosaOperator::attribute_as<tosa::COS_Attribute>() const {
  return attribute_as_COS_Attribute();
}

template<> inline const tosa::EXP_Attribute *TosaOperator::attribute_as<tosa::EXP_Attribute>() const {
  return attribute_as_EXP_Attribute();
}

template<> inline const tosa::FLOOR_Attribute *TosaOperator::attribute_as<tosa::FLOOR_Attribute>() const {
  return attribute_as_FLOOR_Attribute();
}

template<> inline const tosa::LOG_Attribute *TosaOperator::attribute_as<tosa::LOG_Attribute>() const {
  return attribute_as_LOG_Attribute();
}

template<> inline const tosa::LOGICAL_NOT_Attribute *TosaOperator::attribute_as<tosa::LOGICAL_NOT_Attribute>() const {
  return attribute_as_LOGICAL_NOT_Attribute();
}

template<> inline const tosa::NEGATE_Attribute *TosaOperator::attribute_as<tosa::NEGATE_Attribute>() const {
  return attribute_as_NEGATE_Attribute();
}

template<> inline const tosa::RECIPROCAL_Attribute *TosaOperator::attribute_as<tosa::RECIPROCAL_Attribute>() const {
  return attribute_as_RECIPROCAL_Attribute();
}

template<> inline const tosa::RSQRT_Attribute *TosaOperator::attribute_as<tosa::RSQRT_Attribute>() const {
  return attribute_as_RSQRT_Attribute();
}

template<> inline const tosa::SIN_Attribute *TosaOperator::attribute_as<tosa::SIN_Attribute>() const {
  return attribute_as_SIN_Attribute();
}

template<> inline const tosa::SELECT_Attribute *TosaOperator::attribute_as<tosa::SELECT_Attribute>() const {
  return attribute_as_SELECT_Attribute();
}

template<> inline const tosa::EQUAL_Attribute *TosaOperator::attribute_as<tosa::EQUAL_Attribute>() const {
  return attribute_as_EQUAL_Attribute();
}

template<> inline const tosa::GREATER_Attribute *TosaOperator::attribute_as<tosa::GREATER_Attribute>() const {
  return attribute_as_GREATER_Attribute();
}

template<> inline const tosa::GREATER_EQUAL_Attribute *TosaOperator::attribute_as<tosa::GREATER_EQUAL_Attribute>() const {
  return attribute_as_GREATER_EQUAL_Attribute();
}

template<> inline const tosa::REDUCE_ALL_Attribute *TosaOperator::attribute_as<tosa::REDUCE_ALL_Attribute>() const {
  return attribute_as_REDUCE_ALL_Attribute();
}

template<> inline const tosa::REDUCE_ANY_Attribute *TosaOperator::attribute_as<tosa::REDUCE_ANY_Attribute>() const {
  return attribute_as_REDUCE_ANY_Attribute();
}

template<> inline const tosa::REDUCE_MAX_Attribute *TosaOperator::attribute_as<tosa::REDUCE_MAX_Attribute>() const {
  return attribute_as_REDUCE_MAX_Attribute();
}

template<> inline const tosa::REDUCE_MIN_Attribute *TosaOperator::attribute_as<tosa::REDUCE_MIN_Attribute>() const {
  return attribute_as_REDUCE_MIN_Attribute();
}

template<> inline const tosa::REDUCE_PRODUCT_Attribute *TosaOperator::attribute_as<tosa::REDUCE_PRODUCT_Attribute>() const {
  return attribute_as_REDUCE_PRODUCT_Attribute();
}

template<> inline const tosa::REDUCE_SUM_Attribute *TosaOperator::attribute_as<tosa::REDUCE_SUM_Attribute>() const {
  return attribute_as_REDUCE_SUM_Attribute();
}

template<> inline const tosa::CONCAT_Attribute *TosaOperator::attribute_as<tosa::CONCAT_Attribute>() const {
  return attribute_as_CONCAT_Attribute();
}

template<> inline const tosa::PAD_Attribute *TosaOperator::attribute_as<tosa::PAD_Attribute>() const {
  return attribute_as_PAD_Attribute();
}

template<> inline const tosa::RESHAPE_Attribute *TosaOperator::attribute_as<tosa::RESHAPE_Attribute>() const {
  return attribute_as_RESHAPE_Attribute();
}

template<> inline const tosa::REVERSE_Attribute *TosaOperator::attribute_as<tosa::REVERSE_Attribute>() const {
  return attribute_as_REVERSE_Attribute();
}

template<> inline const tosa::SLICE_Attribute *TosaOperator::attribute_as<tosa::SLICE_Attribute>() const {
  return attribute_as_SLICE_Attribute();
}

template<> inline const tosa::TILE_Attribute *TosaOperator::attribute_as<tosa::TILE_Attribute>() const {
  return attribute_as_TILE_Attribute();
}

template<> inline const tosa::TRANSPOSE_Attribute *TosaOperator::attribute_as<tosa::TRANSPOSE_Attribute>() const {
  return attribute_as_TRANSPOSE_Attribute();
}

template<> inline const tosa::GATHER_Attribute *TosaOperator::attribute_as<tosa::GATHER_Attribute>() const {
  return attribute_as_GATHER_Attribute();
}

template<> inline const tosa::SCATTER_Attribute *TosaOperator::attribute_as<tosa::SCATTER_Attribute>() const {
  return attribute_as_SCATTER_Attribute();
}

template<> inline const tosa::RESIZE_Attribute *TosaOperator::attribute_as<tosa::RESIZE_Attribute>() const {
  return attribute_as_RESIZE_Attribute();
}

template<> inline const tosa::CAST_Attribute *TosaOperator::attribute_as<tosa::CAST_Attribute>() const {
  return attribute_as_CAST_Attribute();
}

template<> inline const tosa::CAST_STOCHASTIC_Attribute *TosaOperator::attribute_as<tosa::CAST_STOCHASTIC_Attribute>() const {
  return attribute_as_CAST_STOCHASTIC_Attribute();
}

template<> inline const tosa::RESCALE_Attribute *TosaOperator::attribute_as<tosa::RESCALE_Attribute>() const {
  return attribute_as_RESCALE_Attribute();
}

template<> inline const tosa::CONST_Attribute *TosaOperator::attribute_as<tosa::CONST_Attribute>() const {
  return attribute_as_CONST_Attribute();
}

template<> inline const tosa::RAND_SEED_Attribute *TosaOperator::attribute_as<tosa::RAND_SEED_Attribute>() const {
  return attribute_as_RAND_SEED_Attribute();
}

template<> inline const tosa::RAND_UNIFORM_Attribute *TosaOperator::attribute_as<tosa::RAND_UNIFORM_Attribute>() const {
  return attribute_as_RAND_UNIFORM_Attribute();
}

template<> inline const tosa::IDENTITY_Attribute *TosaOperator::attribute_as<tosa::IDENTITY_Attribute>() const {
  return attribute_as_IDENTITY_Attribute();
}

template<> inline const tosa::CUSTOM_Attribute *TosaOperator::attribute_as<tosa::CUSTOM_Attribute>() const {
  return attribute_as_CUSTOM_Attribute();
}

template<> inline const tosa::COND_IF_Attribute *TosaOperator::attribute_as<tosa::COND_IF_Attribute>() const {
  return attribute_as_COND_IF_Attribute();
}

template<> inline const tosa::WHILE_LOOP_Attribute *TosaOperator::attribute_as<tosa::WHILE_LOOP_Attribute>() const {
  return attribute_as_WHILE_LOOP_Attribute();
}

template<> inline const tosa::YIELD_Attribute *TosaOperator::attribute_as<tosa::YIELD_Attribute>() const {
  return attribute_as_YIELD_Attribute();
}

template<> inline const tosa::VARIABLE_Attribute *TosaOperator::attribute_as<tosa::VARIABLE_Attribute>() const {
  return attribute_as_VARIABLE_Attribute();
}

template<> inline const tosa::VARIABLE_WRITE_Attribute *TosaOperator::attribute_as<tosa::VARIABLE_WRITE_Attribute>() const {
  return attribute_as_VARIABLE_WRITE_Attribute();
}

template<> inline const tosa::VARIABLE_READ_Attribute *TosaOperator::attribute_as<tosa::VARIABLE_READ_Attribute>() const {
  return attribute_as_VARIABLE_READ_Attribute();
}

template<> inline const tosa::CONST_SHAPE_Attribute *TosaOperator::attribute_as<tosa::CONST_SHAPE_Attribute>() const {
  return attribute_as_CONST_SHAPE_Attribute();
}

struct TosaOperatorBuilder {
  typedef TosaOperator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(tosa::Op op) {
    fbb_.AddElement<uint32_t>(TosaOperator::VT_OP, static_cast<uint32_t>(op), 0);
  }
  void add_attribute_type(tosa::Attribute attribute_type) {
    fbb_.AddElement<uint8_t>(TosaOperator::VT_ATTRIBUTE_TYPE, static_cast<uint8_t>(attribute_type), 0);
  }
  void add_attribute(::flatbuffers::Offset<void> attribute) {
    fbb_.AddOffset(TosaOperator::VT_ATTRIBUTE, attribute);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs) {
    fbb_.AddOffset(TosaOperator::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs) {
    fbb_.AddOffset(TosaOperator::VT_OUTPUTS, outputs);
  }
  explicit TosaOperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TosaOperator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TosaOperator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TosaOperator> CreateTosaOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tosa::Op op = tosa::Op_UNKNOWN,
    tosa::Attribute attribute_type = tosa::Attribute_NONE,
    ::flatbuffers::Offset<void> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0) {
  TosaOperatorBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_attribute(attribute);
  builder_.add_op(op);
  builder_.add_attribute_type(attribute_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaOperator> CreateTosaOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tosa::Op op = tosa::Op_UNKNOWN,
    tosa::Attribute attribute_type = tosa::Attribute_NONE,
    ::flatbuffers::Offset<void> attribute = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
  return tosa::CreateTosaOperator(
      _fbb,
      op,
      attribute_type,
      attribute,
      inputs__,
      outputs__);
}

struct TosaBasicBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TosaBasicBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OPERATORS = 6,
    VT_TENSORS = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaOperator>> *operators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaOperator>> *>(VT_OPERATORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaTensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaTensor>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct TosaBasicBlockBuilder {
  typedef TosaBasicBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TosaBasicBlock::VT_NAME, name);
  }
  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaOperator>>> operators) {
    fbb_.AddOffset(TosaBasicBlock::VT_OPERATORS, operators);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaTensor>>> tensors) {
    fbb_.AddOffset(TosaBasicBlock::VT_TENSORS, tensors);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs) {
    fbb_.AddOffset(TosaBasicBlock::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs) {
    fbb_.AddOffset(TosaBasicBlock::VT_OUTPUTS, outputs);
  }
  explicit TosaBasicBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TosaBasicBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TosaBasicBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TosaBasicBlock> CreateTosaBasicBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaOperator>>> operators = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaTensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0) {
  TosaBasicBlockBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  builder_.add_operators(operators);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaBasicBlock> CreateTosaBasicBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<tosa::TosaOperator>> *operators = nullptr,
    const std::vector<::flatbuffers::Offset<tosa::TosaTensor>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<tosa::TosaOperator>>(*operators) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<tosa::TosaTensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
  return tosa::CreateTosaBasicBlock(
      _fbb,
      name__,
      operators__,
      tensors__,
      inputs__,
      outputs__);
}

struct TosaRegion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TosaRegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BLOCKS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaBasicBlock>> *blocks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaBasicBlock>> *>(VT_BLOCKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           verifier.EndTable();
  }
};

struct TosaRegionBuilder {
  typedef TosaRegion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TosaRegion::VT_NAME, name);
  }
  void add_blocks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaBasicBlock>>> blocks) {
    fbb_.AddOffset(TosaRegion::VT_BLOCKS, blocks);
  }
  explicit TosaRegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TosaRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TosaRegion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TosaRegion> CreateTosaRegion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaBasicBlock>>> blocks = 0) {
  TosaRegionBuilder builder_(_fbb);
  builder_.add_blocks(blocks);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaRegion> CreateTosaRegionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<tosa::TosaBasicBlock>> *blocks = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto blocks__ = blocks ? _fbb.CreateVector<::flatbuffers::Offset<tosa::TosaBasicBlock>>(*blocks) : 0;
  return tosa::CreateTosaRegion(
      _fbb,
      name__,
      blocks__);
}

struct TosaGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TosaGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_REGIONS = 6
  };
  const tosa::Version *version() const {
    return GetPointer<const tosa::Version *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaRegion>> *regions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaRegion>> *>(VT_REGIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_REGIONS) &&
           verifier.VerifyVector(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           verifier.EndTable();
  }
};

struct TosaGraphBuilder {
  typedef TosaGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<tosa::Version> version) {
    fbb_.AddOffset(TosaGraph::VT_VERSION, version);
  }
  void add_regions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaRegion>>> regions) {
    fbb_.AddOffset(TosaGraph::VT_REGIONS, regions);
  }
  explicit TosaGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TosaGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TosaGraph>(end);
    fbb_.Required(o, TosaGraph::VT_VERSION);
    return o;
  }
};

inline ::flatbuffers::Offset<TosaGraph> CreateTosaGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tosa::Version> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosa::TosaRegion>>> regions = 0) {
  TosaGraphBuilder builder_(_fbb);
  builder_.add_regions(regions);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaGraph> CreateTosaGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tosa::Version> version = 0,
    const std::vector<::flatbuffers::Offset<tosa::TosaRegion>> *regions = nullptr) {
  auto regions__ = regions ? _fbb.CreateVector<::flatbuffers::Offset<tosa::TosaRegion>>(*regions) : 0;
  return tosa::CreateTosaGraph(
      _fbb,
      version,
      regions__);
}

inline bool VerifyAttribute(::flatbuffers::Verifier &verifier, const void *obj, Attribute type) {
  switch (type) {
    case Attribute_NONE: {
      return true;
    }
    case Attribute_ARGMAX_Attribute: {
      auto ptr = reinterpret_cast<const tosa::ARGMAX_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_AVG_POOL2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::AVG_POOL2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CONV2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CONV2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CONV3D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CONV3D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_DEPTHWISE_CONV2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::DEPTHWISE_CONV2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_FFT2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::FFT2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_MATMUL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::MATMUL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_MAX_POOL2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::MAX_POOL2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RFFT2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RFFT2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_TRANSPOSE_CONV2D_Attribute: {
      auto ptr = reinterpret_cast<const tosa::TRANSPOSE_CONV2D_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CLAMP_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CLAMP_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_ERF_Attribute: {
      auto ptr = reinterpret_cast<const tosa::ERF_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SIGMOID_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SIGMOID_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_TANH_Attribute: {
      auto ptr = reinterpret_cast<const tosa::TANH_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_ADD_Attribute: {
      auto ptr = reinterpret_cast<const tosa::ADD_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_ARITHMETIC_RIGHT_SHIFT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::ARITHMETIC_RIGHT_SHIFT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_BITWISE_AND_Attribute: {
      auto ptr = reinterpret_cast<const tosa::BITWISE_AND_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_BITWISE_OR_Attribute: {
      auto ptr = reinterpret_cast<const tosa::BITWISE_OR_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_BITWISE_XOR_Attribute: {
      auto ptr = reinterpret_cast<const tosa::BITWISE_XOR_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_INTDIV_Attribute: {
      auto ptr = reinterpret_cast<const tosa::INTDIV_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_AND_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_AND_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_LEFT_SHIFT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_LEFT_SHIFT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_RIGHT_SHIFT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_RIGHT_SHIFT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_OR_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_OR_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_XOR_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_XOR_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_MAXIMUM_Attribute: {
      auto ptr = reinterpret_cast<const tosa::MAXIMUM_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_MINIMUM_Attribute: {
      auto ptr = reinterpret_cast<const tosa::MINIMUM_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_MUL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::MUL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_POW_Attribute: {
      auto ptr = reinterpret_cast<const tosa::POW_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SUB_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SUB_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_TABLE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::TABLE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_ABS_Attribute: {
      auto ptr = reinterpret_cast<const tosa::ABS_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_BITWISE_NOT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::BITWISE_NOT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CEIL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CEIL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CLZ_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CLZ_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_COS_Attribute: {
      auto ptr = reinterpret_cast<const tosa::COS_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_EXP_Attribute: {
      auto ptr = reinterpret_cast<const tosa::EXP_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_FLOOR_Attribute: {
      auto ptr = reinterpret_cast<const tosa::FLOOR_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOG_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOG_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_LOGICAL_NOT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::LOGICAL_NOT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_NEGATE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::NEGATE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RECIPROCAL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RECIPROCAL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RSQRT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RSQRT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SIN_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SIN_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SELECT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SELECT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_EQUAL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::EQUAL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_GREATER_Attribute: {
      auto ptr = reinterpret_cast<const tosa::GREATER_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_GREATER_EQUAL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::GREATER_EQUAL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_ALL_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_ALL_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_ANY_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_ANY_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_MAX_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_MAX_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_MIN_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_MIN_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_PRODUCT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_PRODUCT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REDUCE_SUM_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REDUCE_SUM_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CONCAT_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CONCAT_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_PAD_Attribute: {
      auto ptr = reinterpret_cast<const tosa::PAD_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RESHAPE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RESHAPE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_REVERSE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::REVERSE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SLICE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SLICE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_TILE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::TILE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_TRANSPOSE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::TRANSPOSE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_GATHER_Attribute: {
      auto ptr = reinterpret_cast<const tosa::GATHER_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_SCATTER_Attribute: {
      auto ptr = reinterpret_cast<const tosa::SCATTER_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RESIZE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RESIZE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CAST_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CAST_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CAST_STOCHASTIC_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CAST_STOCHASTIC_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RESCALE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RESCALE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CONST_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CONST_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RAND_SEED_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RAND_SEED_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_RAND_UNIFORM_Attribute: {
      auto ptr = reinterpret_cast<const tosa::RAND_UNIFORM_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_IDENTITY_Attribute: {
      auto ptr = reinterpret_cast<const tosa::IDENTITY_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CUSTOM_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CUSTOM_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_COND_IF_Attribute: {
      auto ptr = reinterpret_cast<const tosa::COND_IF_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_WHILE_LOOP_Attribute: {
      auto ptr = reinterpret_cast<const tosa::WHILE_LOOP_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_YIELD_Attribute: {
      auto ptr = reinterpret_cast<const tosa::YIELD_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_VARIABLE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::VARIABLE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_VARIABLE_WRITE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::VARIABLE_WRITE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_VARIABLE_READ_Attribute: {
      auto ptr = reinterpret_cast<const tosa::VARIABLE_READ_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Attribute_CONST_SHAPE_Attribute: {
      auto ptr = reinterpret_cast<const tosa::CONST_SHAPE_Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAttribute(
        verifier,  values->Get(i), types->GetEnum<Attribute>(i))) {
      return false;
    }
  }
  return true;
}

inline const tosa::TosaGraph *GetTosaGraph(const void *buf) {
  return ::flatbuffers::GetRoot<tosa::TosaGraph>(buf);
}

inline const tosa::TosaGraph *GetSizePrefixedTosaGraph(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tosa::TosaGraph>(buf);
}

inline const char *TosaGraphIdentifier() {
  return "TOSA";
}

inline bool TosaGraphBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TosaGraphIdentifier());
}

inline bool SizePrefixedTosaGraphBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TosaGraphIdentifier(), true);
}

inline bool VerifyTosaGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tosa::TosaGraph>(TosaGraphIdentifier());
}

inline bool VerifySizePrefixedTosaGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tosa::TosaGraph>(TosaGraphIdentifier());
}

inline const char *TosaGraphExtension() {
  return "tosa";
}

inline void FinishTosaGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tosa::TosaGraph> root) {
  fbb.Finish(root, TosaGraphIdentifier());
}

inline void FinishSizePrefixedTosaGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tosa::TosaGraph> root) {
  fbb.FinishSizePrefixed(root, TosaGraphIdentifier());
}

}  // namespace tosa

#endif  // FLATBUFFERS_GENERATED_TOSA_TOSA_H_
